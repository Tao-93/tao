<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS 概念 | AlexTao 的 博客</title>
    <meta name="description" content="In doing we learn.">
    <link rel="icon" href="favicon.ico">
    
    <link rel="preload" href="/Weblog/assets/css/styles.05873600.css" as="style"><link rel="preload" href="/Weblog/assets/js/app.05873600.js" as="script"><link rel="preload" href="/Weblog/assets/js/47.08c79ff4.js" as="script"><link rel="prefetch" href="/Weblog/assets/css/16.styles.2339a627.css"><link rel="prefetch" href="/Weblog/assets/css/5.styles.c1152841.css"><link rel="prefetch" href="/Weblog/assets/css/7.styles.1f4a6057.css"><link rel="prefetch" href="/Weblog/assets/css/8.styles.5b6e1357.css"><link rel="prefetch" href="/Weblog/assets/js/0.a8dcd889.js"><link rel="prefetch" href="/Weblog/assets/js/10.fe0f74e6.js"><link rel="prefetch" href="/Weblog/assets/js/11.d51cd775.js"><link rel="prefetch" href="/Weblog/assets/js/12.01521323.js"><link rel="prefetch" href="/Weblog/assets/js/13.82c3fc4a.js"><link rel="prefetch" href="/Weblog/assets/js/14.3b16e4be.js"><link rel="prefetch" href="/Weblog/assets/js/15.abf2374c.js"><link rel="prefetch" href="/Weblog/assets/js/16.2339a627.js"><link rel="prefetch" href="/Weblog/assets/js/17.f68b5694.js"><link rel="prefetch" href="/Weblog/assets/js/18.1dc877c8.js"><link rel="prefetch" href="/Weblog/assets/js/19.8d3a8eb9.js"><link rel="prefetch" href="/Weblog/assets/js/2.af3ad6a4.js"><link rel="prefetch" href="/Weblog/assets/js/20.b49a1359.js"><link rel="prefetch" href="/Weblog/assets/js/21.791ceaa2.js"><link rel="prefetch" href="/Weblog/assets/js/22.fc4cbaec.js"><link rel="prefetch" href="/Weblog/assets/js/23.4ad12214.js"><link rel="prefetch" href="/Weblog/assets/js/24.55bc5812.js"><link rel="prefetch" href="/Weblog/assets/js/25.f985eed7.js"><link rel="prefetch" href="/Weblog/assets/js/26.4cb7663f.js"><link rel="prefetch" href="/Weblog/assets/js/27.a14669b1.js"><link rel="prefetch" href="/Weblog/assets/js/28.8620d72f.js"><link rel="prefetch" href="/Weblog/assets/js/29.d0f2b69c.js"><link rel="prefetch" href="/Weblog/assets/js/3.fb06d288.js"><link rel="prefetch" href="/Weblog/assets/js/30.779bb068.js"><link rel="prefetch" href="/Weblog/assets/js/31.40c7de84.js"><link rel="prefetch" href="/Weblog/assets/js/32.ba7c27f0.js"><link rel="prefetch" href="/Weblog/assets/js/33.6ab2c1a8.js"><link rel="prefetch" href="/Weblog/assets/js/34.e8c873d7.js"><link rel="prefetch" href="/Weblog/assets/js/35.e96a75ad.js"><link rel="prefetch" href="/Weblog/assets/js/36.86fbcd91.js"><link rel="prefetch" href="/Weblog/assets/js/37.b26a2882.js"><link rel="prefetch" href="/Weblog/assets/js/38.992c347d.js"><link rel="prefetch" href="/Weblog/assets/js/39.e58d8f81.js"><link rel="prefetch" href="/Weblog/assets/js/4.b91b4b8a.js"><link rel="prefetch" href="/Weblog/assets/js/40.01c8b7bc.js"><link rel="prefetch" href="/Weblog/assets/js/41.75147100.js"><link rel="prefetch" href="/Weblog/assets/js/42.b2377431.js"><link rel="prefetch" href="/Weblog/assets/js/43.3a184450.js"><link rel="prefetch" href="/Weblog/assets/js/44.067bcf22.js"><link rel="prefetch" href="/Weblog/assets/js/45.68ba4476.js"><link rel="prefetch" href="/Weblog/assets/js/46.78e6e5f5.js"><link rel="prefetch" href="/Weblog/assets/js/48.24964852.js"><link rel="prefetch" href="/Weblog/assets/js/49.e7608465.js"><link rel="prefetch" href="/Weblog/assets/js/5.c1152841.js"><link rel="prefetch" href="/Weblog/assets/js/50.35c99ad9.js"><link rel="prefetch" href="/Weblog/assets/js/51.6b5dac05.js"><link rel="prefetch" href="/Weblog/assets/js/52.c4bb9237.js"><link rel="prefetch" href="/Weblog/assets/js/53.e53dd56d.js"><link rel="prefetch" href="/Weblog/assets/js/54.b8170212.js"><link rel="prefetch" href="/Weblog/assets/js/55.3f8a7f90.js"><link rel="prefetch" href="/Weblog/assets/js/56.70171628.js"><link rel="prefetch" href="/Weblog/assets/js/57.bfaf61b1.js"><link rel="prefetch" href="/Weblog/assets/js/58.db4b1b8a.js"><link rel="prefetch" href="/Weblog/assets/js/59.77684353.js"><link rel="prefetch" href="/Weblog/assets/js/6.829d0e7e.js"><link rel="prefetch" href="/Weblog/assets/js/60.6e9d6cac.js"><link rel="prefetch" href="/Weblog/assets/js/61.275c3154.js"><link rel="prefetch" href="/Weblog/assets/js/62.dd80ea43.js"><link rel="prefetch" href="/Weblog/assets/js/63.dbe8bf46.js"><link rel="prefetch" href="/Weblog/assets/js/64.14e4d91c.js"><link rel="prefetch" href="/Weblog/assets/js/65.c15a382b.js"><link rel="prefetch" href="/Weblog/assets/js/66.1eb3e94c.js"><link rel="prefetch" href="/Weblog/assets/js/67.3ae69c25.js"><link rel="prefetch" href="/Weblog/assets/js/68.2e02b211.js"><link rel="prefetch" href="/Weblog/assets/js/69.2016bf42.js"><link rel="prefetch" href="/Weblog/assets/js/7.1f4a6057.js"><link rel="prefetch" href="/Weblog/assets/js/70.8e2ebe5b.js"><link rel="prefetch" href="/Weblog/assets/js/8.5b6e1357.js"><link rel="prefetch" href="/Weblog/assets/js/9.93970f24.js">
    <link rel="stylesheet" href="/Weblog/assets/css/styles.05873600.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/Weblog/" class="home-link router-link-active"><!----><span class="site-name">
      AlexTao 的 博客
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/Weblog/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Classify</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/Weblog/html_css/" class="nav-link">HTML/CSS</a></li><li class="dropdown-item"><!----><a href="/Weblog/javascript/" class="nav-link router-link-active">Javascript</a></li><li class="dropdown-item"><!----><a href="/Weblog/node/" class="nav-link">Node.js</a></li><li class="dropdown-item"><!----><a href="/Weblog/frames/" class="nav-link">Frames</a></li><li class="dropdown-item"><!----><a href="/Weblog/tool/" class="nav-link">Tool</a></li><li class="dropdown-item"><!----><a href="/Weblog/currency/" class="nav-link">Currency</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/AlexTaoClub" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Weblog/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Classify</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/Weblog/html_css/" class="nav-link">HTML/CSS</a></li><li class="dropdown-item"><!----><a href="/Weblog/javascript/" class="nav-link router-link-active">Javascript</a></li><li class="dropdown-item"><!----><a href="/Weblog/node/" class="nav-link">Node.js</a></li><li class="dropdown-item"><!----><a href="/Weblog/frames/" class="nav-link">Frames</a></li><li class="dropdown-item"><!----><a href="/Weblog/tool/" class="nav-link">Tool</a></li><li class="dropdown-item"><!----><a href="/Weblog/currency/" class="nav-link">Currency</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/AlexTaoClub" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>Javascript</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/Weblog/javascript/" aria-current="page" class="sidebar-link">高效javascript</a></li><li><a href="/Weblog/javascript/33个概念.html" class="sidebar-link">JavaScript开发者应懂的33个概念</a></li><li><a href="/Weblog/javascript/js备忘录.html" class="sidebar-link">JS备忘录</a></li><li><a href="/Weblog/javascript/js概念.html" class="active sidebar-link">JS 概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#bfc规范" class="sidebar-link">BFC规范</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#js-自定义事件实现" class="sidebar-link">js 自定义事件实现</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#事件委托，目的，功能，写法" class="sidebar-link">事件委托，目的，功能，写法</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#同源策略" class="sidebar-link">同源策略</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#ajax-原理" class="sidebar-link">Ajax 原理</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#cookie" class="sidebar-link">Cookie</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#浏览器本地存储" class="sidebar-link">浏览器本地存储</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#session" class="sidebar-link">session</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#token" class="sidebar-link">Token</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#线程，进程" class="sidebar-link">线程，进程</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#负载均衡" class="sidebar-link">负载均衡</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#cdn缓存" class="sidebar-link">CDN缓存</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#url到页面加载显示完成" class="sidebar-link">URL到页面加载显示完成</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#seo优化技巧" class="sidebar-link">SEO优化技巧</a></li><li class="sidebar-sub-header"><a href="/Weblog/javascript/js概念.html#垃圾回收机制方式及内存管理" class="sidebar-link">垃圾回收机制方式及内存管理</a></li></ul></li><li><a href="/Weblog/javascript/片段和trick.html" class="sidebar-link">片段和trick</a></li><li><a href="/Weblog/javascript/常用正则.html" class="sidebar-link">常用正则表达式</a></li><li><a href="/Weblog/javascript/处理异步的方法.html" class="sidebar-link">处理异步的方法</a></li><li><a href="/Weblog/javascript/字符串.html" class="sidebar-link">字符串</a></li><li><a href="/Weblog/javascript/数组.html" class="sidebar-link">数组</a></li><li><a href="/Weblog/javascript/浅谈 JSON.html" class="sidebar-link">浅谈 JSON</a></li><li><a href="/Weblog/javascript/详解闭包.html" class="sidebar-link">详解闭包</a></li><li><a href="/Weblog/javascript/执行上下文.html" class="sidebar-link">执行上下文</a></li><li><a href="/Weblog/javascript/this.html" class="sidebar-link">this</a></li><li><a href="/Weblog/javascript/深浅拷贝.html" class="sidebar-link">深浅拷贝</a></li><li><a href="/Weblog/javascript/面向对象.html" class="sidebar-link">面向对象</a></li><li><a href="/Weblog/javascript/继承方式.html" class="sidebar-link">继承方式</a></li><li><a href="/Weblog/javascript/节流防抖.html" class="sidebar-link">节流防抖</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="js-概念">JS 概念</h1><h2 id="bfc规范">BFC规范</h2><p>级格式化上下文，是CSS中的一个渲染机制，BFC就相当于一个盒子，内部的元素与外界的元素互不干扰。它不会影响外部的布局，外部的布局也不会影响到它.</p><ul><li><strong>创建BFC</strong></li></ul><p>1.float的值不是none</p><p>2.position 的值不是static或者relative</p><p>3.display的值是inline-block,table-cell,flex,table-caption或者inline-flex</p><p>4.overflow的值不是visible</p><ul><li><strong>BFC特性</strong></li></ul><p>1.内部的BOX会在垂直方向上一个接一个的放置</p><p>2.于同一个BFC的俩个相邻的BOX的margin会发生重叠，与方向无关。</p><p>3.每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此</p><p>4.BFC的区域不会与float的元素区域重叠</p><p>5.计算BFC的高度时，浮动子元素也参与计算</p><p>6.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</p><ul><li><strong>BFC布局中应用</strong></li></ul><p>要阻止margin重叠，只要将俩个元素别放在一个BFC中即可 使得父元素包含子元素，常见的方式是为父元素设置overflow：hidden或者浮动父元素。根本原因在于创建BFC的元素，子浮动元素也会参与其高度计算，即不会产生高度塌陷问题 与浮动元素相邻的已生成BFC的元素不能与浮动元素互相覆盖。利用该特性可以作为多栏布局的一种实现方式. 特点在于左右俩栏的宽度固定，中间栏可以根据浏览器宽度自适应</p><h2 id="js-自定义事件实现">js 自定义事件实现</h2><ol><li>原生提供了3个方法实现自定义事件</li><li>createEvent，设置事件类型，是 html 事件还是 鼠标事件</li><li>initEvent 初始化事件，事件名称，是否允许冒泡，是否阻止自定义事件</li><li>dispatchEvent 触发事件</li></ol><h2 id="事件委托，目的，功能，写法">事件委托，目的，功能，写法</h2><ul><li><p>把一个或者一组元素的事件委托到它的父层或者更外层元素上</p></li><li><p>优点，减少内存消耗，动态绑定事件</p></li><li><p>target 是触发事件的最具体的元素，currenttarget是绑定事件的元素(在函数中一般等于this)</p></li><li><div class="language-text extra-class"><pre class="language-text"><code>window.onload = function(){
　　var oUl = document.getElementById(&quot;ul1&quot;);
　　oUl.onclick = function(ev){
　　　　var ev = ev || window.event;
　　　　var target = ev.target || ev.srcElement;
　　　　if(target.nodeName.toLowerCase() == 'li'){
　 　　　　　　 alert(123);
　　　　　　　  alert(target.innerHTML);
　　　　}
　　}
}
</code></pre></div></li></ul><h2 id="同源策略">同源策略</h2><p>源（origin）就是协议、域名和端口号。</p><p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。</p><p>这个策略可以阻止一个页面上的恶意脚本通过页面的DOM对象获得访问另一个页面上敏感信息的权限。</p><h3 id="跨域">跨域</h3><p>浏览器同源策略的影响，不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象是就需要跨域。</p><p><strong>cors-跨域资源共享（Cross-origin resource sharing）</strong> ---&gt;这种方式使用了一个新的<code>Origin</code>请求头和一个新的<code>Access-Control-Allow-Origin</code>响应头扩展了HTTP。</p><p>允许服务端设置<code>Access-Control-Allow-Origin</code>头标识哪些站点可以请求文件，或者设置<code>Access-Control-Allow-Origin</code>头为&quot;*&quot;， （IE8---IE9---jquery.xdomainrequest.min.js）</p><p><strong>JSONP</strong>---&gt;JOSNP允许页面接受另一个域的JSON数据，通过在页面增加一个可以从其它域加载带有回调的JSON响应的<code>&lt;script&gt;</code>标签。</p><ol><li><p>使用这种方法，只要是个网站都可以拿到b.com里的数据，存在安全性问题。需要网站双方商议基础token的身份验证，这里不详述。</p><p>. 只能是GET，不能POST。 . 可能被注入恶意代码，篡改页面内容，可以采用字符串过滤来规避此问题。</p></li></ol><p><strong>postMessage() -跨文档通信</strong>---&gt;这种方式允许一个页面的脚本发送文本信息到另一个页面的脚本中，不管脚本是否跨域。</p><p>在一个window对象上调用<code>postMessage()</code>会异步的触发window上的<code>onmessage</code>事件，然后触发定义好的事件处理方法。</p><p>一个页面上的脚本仍然不能直接访问另外一个页面上的方法或者变量，但是他们可以安全的通过消息传递技术交流。</p><p><strong>window.name</strong>---&gt;window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p><h2 id="ajax-原理">Ajax 原理</h2><p>Ajax的全称是Asynchronous JavaScript and XML，即异步JavaScript+XML。  是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><p>由以下几种技术组成：</p><ul><li>HTML/XHTML——主要的内容表示语言。</li><li>CSS——为XHTML提供文本格式定义。</li><li>DOM——对已载入的页面进行动态更新。</li><li>XML——数据交换格式。</li><li>XSLT——将XML转换为XHTML（用CSS修饰样式）。</li><li>XMLHttp——用XMLHttpRequest来和服务器进行异步通信，是主要的通信代理。</li><li>JavaScript——用来编写Ajax引擎的脚本语言。</li></ul><p><strong>Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。</strong></p><p><strong>XMLHttpRequest对象</strong></p><p>当需要异步与服务器交换数据时，需要XMLHttpRequest对象来异步交换。 XMLHttpRequest对象的主要<strong>属性</strong>有：</p><ul><li>onreadystatechange——每次状态改变所触发事件的事件处理程序。</li><li>responseText——从服务器进程返回数据的字符串形式。</li><li>responseXML——从服务器进程返回的DOM兼容的文档数据对象。</li><li>status——从服务器返回的数字代码，如404（未找到）和200（已就绪）。</li><li>status Text——伴随状态码的字符串信息。</li><li>readyState——对象状态值。对象状态值有以下几个：
<ul><li>0 - (未初始化)还没有调用send()方法</li><li>1 - (载入)已调用send()方法，正在发送请求</li><li>2 - (载入完成)send()方法执行完成</li><li>3 - (交互)正在解析响应内容</li><li>4 - (完成)响应内容解析完成，可以在客户端调用了</li></ul></li></ul><p>XMLHttpRequest对象有两个重要<strong>方法</strong> open与send。</p><p><strong>创建过程</strong></p><ul><li><p>创建XMLHttpRequest对象</p><ul><li><div class="language-text extra-class"><pre class="language-text"><code>  var xmlhttp = new XMLHttpRequest();                    //IE7及以上
  var xmlhttp = new ActiveXObject('Microsoft.XMLHTTP'); //IE5 和 IE6
</code></pre></div></li></ul></li><li><p>打开链接</p><ul><li><div class="language-text extra-class"><pre class="language-text"><code>xmlhttp.open( method, url, async );  
</code></pre></div></li><li><div class="language-text extra-class"><pre class="language-text"><code>method：请求的类型，GET 或 POST
url：文件在服务器上的位置
async：true（异步）或 false（同步）
同步：指发出数据后，等接收到响应以后再发送下一个数据包的通讯方式。
异步：指发出数据后，不用等待接收到响应，接着发送下一个数据包的通讯方式。
</code></pre></div></li></ul></li><li><p>发送请求</p><ul><li><div class="language-text extra-class"><pre class="language-text"><code>xmlhttp.send(string);
</code></pre></div><ul><li><div class="language-text extra-class"><pre class="language-text"><code>xmlhttp.send();    //GET方式
</code></pre></div></li><li><div class="language-text extra-class"><pre class="language-text"><code>xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);    //向请求添加HTTP头
xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;);   //POST方式
</code></pre></div></li></ul></li><li><p><strong>GET 还是 POST？</strong></p><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求：  a. 无法使用缓存文件（更新服务器上的文件或数据库）；  b. 向服务器发送大量数据（POST 没有数据量限制）；  c. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠。</p></li></ul></li><li><p>接收服务器相应</p><ul><li><p><strong>Onreadystatechange</strong> ---存储函数（或函数名），每当readyState 属性改变时，就会调用该函数。</p></li><li><p>readyState</p><p>---存有XMLHttpRequest 的状态信息，从 0 到 4 发生变化。</p><ul><li>0: 请求未初始化</li><li>1: 服务器连接已建立</li><li>2: 请求已接收</li><li>3: 请求处理中</li><li>4: 请求已完成，且响应已就绪</li></ul></li><li><p>Status（HTTP状态码）</p><ul><li>1字头：消息。这一类型的状态码，代表请求已被接受，需要继续处理。</li><li>2字头：成功。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。( 200:'OK' )</li><li>3字头：重定向。这类状态码代表需要客户端采取进一步的操作才能完成请求。( 304:'Not Modified' )</li><li>4字头：请求错误。这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。</li><li>5、6字头：服务器错误。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生。</li></ul></li></ul></li></ul><p>每当 readyState 改变时，就会触发 onreadystatechange 事件。</p><div class="language-text extra-class"><pre class="language-text"><code>//GET 方式：
  function ajax(url,success,error){
      if(window.XMLHttpRequest){
          var oAjax = new XMLHttpRequest();
      }else{
          var oAjax = new ActiveXObject('Microsoft.XMLHTTP');
      }
      oAjax.open('GET',url,true);
      oAjax.send();
      oAjax.onreadystatechange = function(){
          if(oAjax.readyState==4){
              if(oAjax.status&gt;=200&amp;&amp;oAjax.status&lt;300||oAjax.status==304){
                  success&amp;&amp;success(oAjax.responseText);    //成功的回调函数
              }else{
                  error&amp;&amp;error(oAjax.status);              //失败的回调函
              }
          }
      };
  }
//POST 方式：
  function ajax(url,success,error){
      if(window.XMLHttpRequest){
          var oAjax = new XMLHttpRequest();
      }else{
          var oAjax = new ActiveXObject('Microsoft.XMLHTTP');
      }
      oAjax.open('POST ',url,true);
      oAjax.setRequestHeader('Content-Type','application/x-www-form-urlencoded');
      oAjax.send('fname=Bill&amp;lname=Gates');
      oAjax.onreadystatechange = function(){
          if(oAjax.readyState==4){
              if(oAjax.status&gt;=200&amp;&amp;oAjax.status&lt;300||oAjax.status==304){
                  success&amp;&amp;success(oAjax.responseText);    //成功的回调函数
              }else{
                  error&amp;&amp;error(oAjax.status);              //失败的回调函
              }
          }
      };
  }
$.ajax({
    type: &quot;get&quot;,
    url: &quot;http://www.github.com/alex&quot;,
    data: {
    	id : &quot;1&quot;,
    	name : &quot;alex&quot;,
    },
    dataType: &quot;json&quot;,
    beforeSend: function(XMLHttpRequest) {
        //ShowLoading();
    },
    success: function(data, textStatus) {
        //请求成功处理
    },
    complete: function(XMLHttpRequest, textStatus) {
        //HideLoading();
    },
    error: function() {
        //请求出错处理
    }
});
</code></pre></div><h3 id="get和post">get和post</h3><ul><li>GET从指定的资源请求数据，POST 向指定的资源提交要被处理的数据</li><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li><li>GET参数通过URL传递，POST放在Request body中。</li><li>GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</li></ul><h3 id="cookie自动登录">cookie自动登录</h3><div class="language-text extra-class"><pre class="language-text"><code>//记住用户名密码----是否自动登录
function Save() {
    if ($(&quot;#rememberMe&quot;).prop(&quot;checked&quot;)) {
        var str_username = $(&quot;#NameText&quot;).val();//用户名
        var str_password = $(&quot;#inputPassword&quot;).val();//密码
        $.cookie(&quot;rmbUser&quot;, &quot;true&quot;, { expires: 7 }); //存储一个带7天期限的cookie
        $.cookie(&quot;username&quot;, str_username, { expires: 7 });
        $.cookie(&quot;password&quot;, str_password, { expires: 7 });
    }else {
        $.cookie(&quot;rmbUser&quot;, &quot;false&quot;, { expire: -1 });
        $.cookie(&quot;username&quot;, &quot;&quot;, { expires: -1 });
        $.cookie(&quot;password&quot;, &quot;&quot;, { expires: -1 });
    }

    if ($(&quot;#autoLogin&quot;).prop(&quot;checked&quot;)) {
        var str_username = $(&quot;#NameText&quot;).val();
        var str_password = $(&quot;#inputPassword&quot;).val();
        $.cookie(&quot;auto&quot;, &quot;true&quot;, { expires: 7 }); //存储一个带7天期限的cookie
        $.cookie(&quot;username&quot;, str_username, { expires: 7 });
        $.cookie(&quot;password&quot;, str_password, { expires: 7 });
    }else {
        $.cookie(&quot;auto&quot;, &quot;false&quot;, { expire: -1 });
        $.cookie(&quot;username&quot;, &quot;&quot;, { expires: -1 });
        $.cookie(&quot;password&quot;, &quot;&quot;, { expires: -1 });
    }
}
$(&quot;#autoLogin&quot;).change(function() {
    if($(&quot;#autoLogin&quot;).prop(&quot;checked&quot;)){
    	$.cookie(&quot;auto&quot;, &quot;true&quot;, { expires: 7 });
    }else{
    	$.cookie(&quot;auto&quot;, &quot;false&quot;, { expires: 7 });
    }
});

if ($.cookie(&quot;rmbUser&quot;) == &quot;true&quot;) {
    $(&quot;#rememberMe&quot;).attr(&quot;checked&quot;, true);
    $(&quot;#NameText&quot;).val($.cookie(&quot;username&quot;));
    $(&quot;#inputPassword&quot;).val($.cookie(&quot;password&quot;));
}

if ($.cookie(&quot;auto&quot;) == &quot;true&quot;) {
    setTimeout(function(){
    	if($.cookie(&quot;auto&quot;) == &quot;true&quot;) 
    	window.location.href='下一个界面';
    },5000);
}
</code></pre></div><h2 id="cookie">Cookie</h2><ul><li>特点
<ul><li>每个特定的域名下最多生成20个cookie
<ul><li>1.IE6及跟早版本最多20个cookie</li><li>2.IE7和之后版本最多50个cookie</li><li>3.firefox最多50个cookie</li><li>4.chrome和safire没有硬性限制</li></ul></li><li>cookie大小大约4096字节，一般不超过4095个字节。</li></ul></li><li>优点
<ul><li>极高的扩张性和可用性
<ul><li>1.通过良好的编程，控制保存在cookie中的session对象的大小。</li><li>2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。</li><li>3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。</li><li>4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。</li></ul></li></ul></li><li>缺点
<ul><li>1
<ul><li>1.cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。</li><li>2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</li><li>3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</li></ul></li></ul></li></ul><h2 id="浏览器本地存储">浏览器本地存储</h2><ul><li><p><strong>localStotrage</strong></p><p>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</p><ul><li>优点
<ul><li>1.localStorage拓展了cookie的4K限制；</li><li>2.localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的；</li><li>3.localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。</li></ul></li><li>缺点
<ul><li>1.浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性；</li><li>2.目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换；</li><li>3.localStorage在浏览器的隐私模式下面是不可读取的；</li><li>4.localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡；</li><li>5.localStorage不能被爬虫抓取到。</li></ul></li></ul></li><li><p><strong>sessionStrage</strong></p><p>本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。 因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储</p></li></ul><h3 id="web-storage-与-cookie">web storage 与 cookie</h3><p><strong>相同点</strong> ： 1.存储在客户端 2.同源策略影响</p><p><strong>不同点</strong> ：</p><p>1.cookie的大小是受限的，cookie大小4KB，storage大小5M。</p><p>2.每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，storage不会发送信息去服务器。</p><p>3.cookie还需要指定作用域，不可以跨域调用 cookie需要前端开发者自己封装setCookie，getCookie。</p><p>4.cookie在过期时间内有效；sessionStorage在当前浏览器窗口关闭自动删除，会话级别；loaclStoage永久有效，除非主动删除。</p><h2 id="session">session</h2><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。</p><p>当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。</p><p>用户首次与Web服务器建立连接的时候，服务器会给用户分发一个 SessionID作为标识。SessionID是一个由24个字符组成的随机字符串。用户每次提交页面，浏览器都会把这个SessionID包含在 HTTP头中提交给Web服务器，这样Web服务器就能区分当前请求页面的是哪一个客户端。这个SessionID就是保存在客户端的，属于客户端Session。其实客户端Session默认是以cookie的形式来存储的。</p><p>当然我们客户端可以禁用cookie,这时候服务器端就拿不到sessionID。</p><h2 id="token">Token</h2><p>Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li><li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li></ol><h2 id="线程，进程">线程，进程</h2><ul><li>进程
<ul><li>所存储资源是操作系统由虚拟内存机制来管理和分配的。<strong>进程应该是操作系统分配存储资源的最小单元。</strong></li><li>一个进程可以有多个线程，但至少有一个线程</li><li>进程表示一个逻辑控制流，就是一种计算过程，它造成一个假象，好像这个进程一直在独占CPU资源</li><li>进程拥有一个独立的虚拟内存地址空间，它造成一个假象，好像这个进程一致在独占存储器资源</li></ul></li><li>线程
<ul><li>线程是最小的执行单元</li><li>一个线程只能属于一个进程</li></ul></li></ul><h2 id="负载均衡">负载均衡</h2><ol><li>当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向扩展，使用集群和负载均衡提高整个系统的处理能力以及网站的整体性能 。</li><li>服务器集群负载均衡原理？</li></ol><h2 id="cdn缓存">CDN缓存</h2><ol><li>CDN 是一种部署策略，根据不同的地区部署类似nginx 这种服务服务，会缓存静态资源。前端在项目优化的时候，习惯在讲台资源上加上一个 hash 值，每次更新的时候去改变这个 hash，hash 值变化的时候，服务会去重新取资源</li><li>(CDN)是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件</li><li>CDN的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/4034265" target="_blank" rel="noopener noreferrer">内容分发网络<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置<a href="https://baike.baidu.com/item/%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E5%99%A8/4576219" target="_blank" rel="noopener noreferrer">节点服务器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>所构成的在现有的互联网基础之上的一层智能<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C/855117" target="_blank" rel="noopener noreferrer">虚拟网络<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，CDN系统能够实时地根据<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F/7489548" target="_blank" rel="noopener noreferrer">网络流量<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</li></ol><h2 id="url到页面加载显示完成">URL到页面加载显示完成</h2><ul><li>首先，在浏览器地址栏中输入url</li><li>浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。
<ul><li>具体过程：</li><li>浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求</li><li>操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的DNS查询缓存)</li><li>ISP缓存：若上述均失败，继续向ISP搜索</li></ul></li><li>发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。</li><li>浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。</li><li>握手成功后，浏览器向服务器发送http请求，请求数据包。</li><li>服务器处理收到的请求，将数据返回至浏览器</li><li>浏览器收到HTTP响应</li><li>读取页面内容，浏览器渲染，解析html源码</li><li>生成Dom树、解析css样式、js交互</li><li>户端和服务器交互</li><li>ajax查询</li></ul><h2 id="seo优化技巧">SEO优化技巧</h2><p>前端开发工程师不仅需要要跟视觉设计师、交互式设计师配合，完美还原设计图稿，编写兼容各大浏览器、加载速度快、用户体验好的页面。现在还需要跟SEO人员配合，调整页面的代码结构和标签。</p><ul><li>简化代码结构，更利于搜索引擎分析抓取有用内容：页面尽量采用DIV+CSS，当然，表格展现模式用table还是比div方便很多的;所有js、css采用外联方式，图片采用css精灵，减少请求次数。看下下面同样的内容，用div和talbe布局的代码比较，显而易见用div简便的多。</li><li>重要内容优先加载(第一个链接最好是网站主关键词，不刻意要求)，可以用css来处理，索引一篇文章的长度也是有限制的，一定要把最重要的内容，优先展现给蜘蛛，这方面你可以通过查看一些比较大的网页快照来求证。</li><li>每个页面只能出现一次H1标签，H2标签可以多次：H1权重很高，普遍认为仅次于title，一般资讯详情页的标题、商品详情页的标题，都放在H1里。</li><li>图片一定要添加alt属性，title属性可选：蜘蛛不认识图片上的内容，只能通过alt属性来判断，如果是商品列表页，所有商品都加了alt和title的话，容易造成堆砌关键词，所以我一般是只加alt属性。</li><li>图片大小声明：如果图片大小不做定义的话，页面需要重新渲染，就会影响到加载速度。</li><li>链接可根据需求添加title属性以及nofllow值;非特殊性链接，链接地址一定要写入herf属性，有些前端开发人员为了省事，直接用div加个click事件当链接，在视觉上和使用上确实是实现了链接效果，但是做过SEO优化的人 员都知道，蜘蛛目前对于js的支持很差，基本无法读取里面的链接地址。所以说用click事件是绝对不允许的，特别是一些重要的导航链接。</li><li>页面内容尽量不要做成flash、图片、视频，这些东西蜘蛛是抓不到的，就算是必须的，也要生成相应的静态页面。有很多企业站看着很炫，全站flash，老板看着是爽了，做SEO优化的人员就要抓狂了，全站没一个链接。</li><li>除首页外别的页面最好要加上面包屑型导航，导航结构一定要清晰。</li><li>做好404页面，一般会加首页链接及错误提示，并测试其返回状态码为404：
<ul><li>1、用户体验友好，可以留住用户，不至于直接关闭页面;</li><li>2、蜘蛛友好，可以返回抓取其他页面。</li></ul></li><li>网站结构呈扁平状树型，目录结构不宜过深，每个页面离首页最多点击不超过3次，过深不利于搜索引擎的抓取。</li></ul><h2 id="垃圾回收机制方式及内存管理">垃圾回收机制方式及内存管理</h2><ul><li>回收机制方式
<ul><li><strong>定义和用法</strong>：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。</li><li><strong>原理</strong>：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</li></ul></li><li>垃圾回收策略：标记清除(较为常用)和引用计数
<ul><li>标记清除
<ul><li>定义和用法
<ul><li>当变量进入环境时，将变量标记&quot;进入环境&quot;，当变量离开环境时，标记为：&quot;离开环境&quot;。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。</li><li>到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</li></ul></li></ul></li><li>引用计数
<ul><li>定义和用法
<ul><li>引用计数是跟踪记录每个值被引用的次数。</li></ul></li><li>基本原理
<ul><li>就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。</li></ul></li></ul></li></ul></li><li>内存管理
<ul><li>什么时候触发垃圾回收？
<ul><li>垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。</li><li>IE6的垃圾回收是根据内存分配量运行的，当环境中的变量，对象，字符串达到一定数量时触发垃圾回收。垃圾回收器一直处于工作状态，严重影响浏览器性能。</li><li>E7中，垃圾回收器会根据内存分配量与程序占用内存的比例进行动态调整，开始回收工作。</li><li>合理的GC方案：
<ul><li>遍历所有可访问的对象;</li><li>回收已不可访问的对象</li></ul></li><li>GC缺陷：
<ul><li>停止响应其他操作</li></ul></li><li>4、GC优化策略：
<ul><li>分代回收（Generation GC）</li><li>增量GC</li></ul></li></ul></li></ul></li><li>开发过程中遇到的内存泄露情况，如何解决的？
<ul><li>定义和用法
<ul><li>内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。C#和Java等语言采用了自动垃圾回收方法管理内存，几乎不会发生内存泄露。我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，会产生内存泄露。</li></ul></li><li>内存泄露的几种情况:
<ul><li>当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。</li><li>由于是函数内定义函数，并且内部函数--事件回调的引用外暴了，形成了闭包。闭包可以维持函数内局部变量，使其得不到释放。</li></ul></li></ul></li></ul></div><div class="page-edit"><!----><div class="last-updated"><span class="prefix">Last Updated: </span><span class="time">9/20/2020, 12:22:33 PM</span></div></div><!----></div></div></div>
    <script src="/Weblog/assets/js/app.05873600.js" defer></script><script src="/Weblog/assets/js/47.08c79ff4.js" defer></script>
  </body>
</html>
