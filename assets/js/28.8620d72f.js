(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{280:function(e,t,n){"use strict";n.r(t);var o=n(0),r=Object(o.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"数据原理"}},[e._v("数据原理")]),n("h3",{attrs:{id:"mvc"}},[e._v("MVC")]),n("ul",[n("li",[n("strong",[e._v("Model: 模型")]),e._v("（用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法）")]),n("li",[n("strong",[e._v("View: 视图")]),e._v("（渲染页面）")]),n("li",[n("strong",[e._v("Controller: 控制器")]),e._v("（M和V之间的连接器，用于控制应用程序的流程，及页面的业务逻辑）")])]),n("p",[n("strong",[e._v("特点")])]),n("p",[e._v("MVC模式的特点在于实现关注点分离，即应用程序中的数据模型与业务和展示逻辑解耦。在客户端web开发中，就是将模型(M-数据、操作数据)、视图(V-显示数据的HTML元素)之间实现代码分离，松散耦合，使之成为一个更容易开发、维护和测试的客户端应用程序。")]),n("ol",[n("li",[e._v("View 传送指令到 Controller ；")]),n("li",[e._v("Controller 完成业务逻辑后，要求 Model 改变状态 ；")]),n("li",[e._v("Model 将新的数据发送到 View，用户得到反馈。")])]),n("h3",{attrs:{id:"mvvm"}},[e._v("MVVM")]),n("p",[n("strong",[e._v("MVVM")]),e._v("是"),n("strong",[e._v("Model-View-ViewModel")]),e._v("的简写。")]),n("p",[e._v("与此同时，在技术层面，WPF也带来了 诸如**Binding（绑定）、Dependency Property（依赖属性）、Routed Events（路由事件）、Command（命令）、DataTemplate（数据模板）、ControlTemplate（控制模板）**等新特性。"),n("strong",[e._v("MVVM模式其实是MV模式与WPF结合的应用方式时发展演变过来的一种新型架构模式。它立足于原有MVP框架并且把WPF的新特性糅合进去，以应对客户日益复杂的需求变化。")])]),n("p",[e._v("ViewModel 层把 View 需要的层数据暴露，并对 View 层的 "),n("strong",[e._v("数据绑定声明")]),e._v("、 "),n("strong",[e._v("指令声明")]),e._v("、 "),n("strong",[e._v("事件绑定声明")]),e._v(" 负责，也就是处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新。")]),n("p",[n("strong",[e._v("双向绑定技术，当Model变化时，View-Model会自动更新，View也会自动变化")])]),n("h2",{attrs:{id:"双向数据绑定原理"}},[e._v("双向数据绑定原理")]),n("p",[e._v("vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过"),n("code",[e._v("Object.defineProperty()")]),e._v("来劫持各个属性的"),n("code",[e._v("setter")]),e._v("，"),n("code",[e._v("getter")]),e._v("，在数据变动时发布消息给订阅者，触发相应的监听回调。")]),n("p",[n("strong",[e._v("第一步：需要observe的数据对象进行递归遍历")]),e._v("，包括子属性对象的属性，都加上 "),n("code",[e._v("setter")]),e._v("和"),n("code",[e._v("getter")]),e._v(" 这样的话，给这个对象的某个值赋值，就会触发"),n("code",[e._v("setter")]),e._v("，那么就能监听到了数据变化")]),n("p",[n("strong",[e._v("第二步：compile解析模板指令")]),e._v("，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图")]),n("p",[n("strong",[e._v("第三步：Watcher订阅者是Observer和Compile之间通信的桥梁")]),e._v("，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。")]),n("p",[n("strong",[e._v("第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者")]),e._v("，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果")]),n("h2",{attrs:{id:"简单实现"}},[e._v("简单实现")]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<body>\n    <div id='app'>\n        <h3>姓名</h3>\n        <p>{{name}}</p>\n        <h3>年龄</h3>\n        <p1>{{age}}</p1>\n        <p2>{{what}}</p2>\n    </div>\n</body>\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<script>\ndocument.addEventListener('DOMContentLoaded', function() {\n    let opt = { el: '#app', data: { name: '检索中...', age: 20, what: \"?\" } }\n    let vm = new Vue(opt)\n    setTimeout(() => {\n        opt.data.name = 'tao'\n        opt.data.age = 18\n        opt.data.what =  ''\n    }, 2000);\n}, false)\nclass Vue {\n    constructor(opt) {\n        this.opt = opt\n        this.observe(opt.data)\n        let root = document.querySelector(opt.el)\n        this.compile(root)\n    }\n    // 为响应式对象 data 里的每一个 key 绑定一个观察者对象\n    observe(data) {\n        let obv = new Observer()\n        Object.keys(data).forEach(key => {\n            data[\"_\" + key] = data[key]\n            // 通过 getter setter 暴露 for 循环中作用域下的 obv，闭包产生\n            Object.defineProperty(data, key, {\n                get() {\n                    Observer.target && obv.addSubNode({ key, node: Observer.target });\n                    console.log(obv.subNode)\n                    return data['_' + key]\n                },\n                set(newVal) {\n                    obv.update(key, newVal)\n                    data['_' + key] = newVal\n                }\n            })\n        })\n    }\n    // 初始化页面，遍历 DOM，收集每一个key变化时，随之调整的位置，以观察者方法存放起来    \n    compile(node) {\n        [].forEach.call(node.childNodes, child => {\n            if (!child.firstElementChild && /\\{\\{(.*)\\}\\}/.test(child.innerHTML)) {\n                let key = RegExp.$1.trim()\n                child.innerHTML = child.innerHTML.replace(new RegExp('\\\\{\\\\{\\\\s*' + key + '\\\\s*\\\\}\\\\}', 'gm'), this.opt.data[key])\n                Observer.target = child\n                this.opt.data[key] // 触发getter\n                Observer.target = null\n            } else if (child.firstElementChild)\n                console.log(2)\n            this.compile(child)\n        })\n    }\n}\n// 常规观察者类\nclass Observer {\n    constructor() {\n        this.subNode = []\n    }\n    addSubNode(node) {\n        this.subNode.push(node)\n    }\n    update(k, newVal) {\n        this.subNode.forEach(obj => {\n            const { key, node } = obj;\n            if (key === k) {\n                node.innerHTML = newVal\n            }\n        })\n    }\n}\n<\/script>\n")])])]),n("p",[e._v("Now, let's try it 👉")])])}],!1,null,null,null);t.default=r.exports}}]);