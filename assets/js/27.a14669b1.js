(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{279:function(e,n,s){"use strict";s.r(n);var t=s(0),a=Object(t.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"nexttick"}},[e._v("NextTick")]),s("p",[s("code",[e._v("nextTick")]),e._v(" å¯ä»¥è®©æˆ‘ä»¬åœ¨ä¸‹æ¬¡ DOM æ›´æ–°å¾ªçŽ¯ç»“æŸä¹‹åŽæ‰§è¡Œå»¶è¿Ÿå›žè°ƒï¼Œç”¨äºŽèŽ·å¾—æ›´æ–°åŽçš„ DOMã€‚")]),s("p",[e._v("åœ¨ Vue 2.4 ä¹‹å‰éƒ½æ˜¯ä½¿ç”¨çš„ microtasksï¼Œä½†æ˜¯ microtasks çš„ä¼˜å…ˆçº§è¿‡é«˜ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹å¯èƒ½ä¼šå‡ºçŽ°æ¯”äº‹ä»¶å†’æ³¡æ›´å¿«çš„æƒ…å†µï¼Œä½†å¦‚æžœéƒ½ä½¿ç”¨ macrotasks åˆå¯èƒ½ä¼šå‡ºçŽ°æ¸²æŸ“çš„æ€§èƒ½é—®é¢˜ã€‚æ‰€ä»¥åœ¨æ–°ç‰ˆæœ¬ä¸­ï¼Œä¼šé»˜è®¤ä½¿ç”¨ microtasksï¼Œä½†åœ¨ç‰¹æ®Šæƒ…å†µä¸‹ä¼šä½¿ç”¨ macrotasksï¼Œæ¯”å¦‚ v-onã€‚")]),s("p",[e._v("å¯¹äºŽå®žçŽ° macrotasks ï¼Œä¼šå…ˆåˆ¤æ–­æ˜¯å¦èƒ½ä½¿ç”¨ "),s("code",[e._v("setImmediate")]),e._v(" ï¼Œä¸èƒ½çš„è¯é™çº§ä¸º "),s("code",[e._v("MessageChannel")]),e._v("ï¼Œä»¥ä¸Šéƒ½ä¸è¡Œçš„è¯å°±ä½¿ç”¨ "),s("code",[e._v("setTimeout")])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  macroTimerFunc = () => {\n    setImmediate(flushCallbacks)\n  }\n} else if (\n  typeof MessageChannel !== 'undefined' &&\n  (isNative(MessageChannel) ||\n    // PhantomJS\n    MessageChannel.toString() === '[object MessageChannelConstructor]')\n) {\n  const channel = new MessageChannel()\n  const port = channel.port2\n  channel.port1.onmessage = flushCallbacks\n  macroTimerFunc = () => {\n    port.postMessage(1)\n  }\n} else {\n  /* istanbul ignore next */\n  macroTimerFunc = () => {\n    setTimeout(flushCallbacks, 0)\n  }\n}\n")])])]),s("p",[s("code",[e._v("nextTick")]),e._v(" åŒæ—¶ä¹Ÿæ”¯æŒ Promise çš„ä½¿ç”¨ï¼Œä¼šåˆ¤æ–­æ˜¯å¦å®žçŽ°äº† Promise")]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("export function nextTick(cb?: Function, ctx?: Object) {\n  let _resolve\n  // å°†å›žè°ƒå‡½æ•°æ•´åˆè¿›ä¸€ä¸ªæ•°ç»„ä¸­\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e) {\n        handleError(e, ctx, 'nextTick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  if (!pending) {\n    pending = true\n    if (useMacroTask) {\n      macroTimerFunc()\n    } else {\n      microTimerFunc()\n    }\n  }\n  // åˆ¤æ–­æ˜¯å¦å¯ä»¥ä½¿ç”¨ Promise \n  // å¯ä»¥çš„è¯ç»™ _resolve èµ‹å€¼\n  // è¿™æ ·å›žè°ƒå‡½æ•°å°±èƒ½ä»¥ promise çš„æ–¹å¼è°ƒç”¨\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(resolve => {\n      _resolve = resolve\n    })\n  }\n}\n")])])]),s("p",[e._v("Now, let's try it ðŸ‘‰")])])}],!1,null,null,null);n.default=a.exports}}]);