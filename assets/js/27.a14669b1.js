(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{279:function(e,n,s){"use strict";s.r(n);var t=s(0),a=Object(t.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"nexttick"}},[e._v("NextTick")]),s("p",[s("code",[e._v("nextTick")]),e._v(" 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。")]),s("p",[e._v("在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。")]),s("p",[e._v("对于实现 macrotasks ，会先判断是否能使用 "),s("code",[e._v("setImmediate")]),e._v(" ，不能的话降级为 "),s("code",[e._v("MessageChannel")]),e._v("，以上都不行的话就使用 "),s("code",[e._v("setTimeout")])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  macroTimerFunc = () => {\n    setImmediate(flushCallbacks)\n  }\n} else if (\n  typeof MessageChannel !== 'undefined' &&\n  (isNative(MessageChannel) ||\n    // PhantomJS\n    MessageChannel.toString() === '[object MessageChannelConstructor]')\n) {\n  const channel = new MessageChannel()\n  const port = channel.port2\n  channel.port1.onmessage = flushCallbacks\n  macroTimerFunc = () => {\n    port.postMessage(1)\n  }\n} else {\n  /* istanbul ignore next */\n  macroTimerFunc = () => {\n    setTimeout(flushCallbacks, 0)\n  }\n}\n")])])]),s("p",[s("code",[e._v("nextTick")]),e._v(" 同时也支持 Promise 的使用，会判断是否实现了 Promise")]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("export function nextTick(cb?: Function, ctx?: Object) {\n  let _resolve\n  // 将回调函数整合进一个数组中\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e) {\n        handleError(e, ctx, 'nextTick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  if (!pending) {\n    pending = true\n    if (useMacroTask) {\n      macroTimerFunc()\n    } else {\n      microTimerFunc()\n    }\n  }\n  // 判断是否可以使用 Promise \n  // 可以的话给 _resolve 赋值\n  // 这样回调函数就能以 promise 的方式调用\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(resolve => {\n      _resolve = resolve\n    })\n  }\n}\n")])])]),s("p",[e._v("Now, let's try it 👉")])])}],!1,null,null,null);n.default=a.exports}}]);