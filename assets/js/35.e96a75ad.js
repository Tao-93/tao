(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{289:function(e,t,n){"use strict";n.r(t);var r=n(0),o=Object(r.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"登录拦截逻辑"}},[e._v("登录拦截逻辑")]),n("h2",{attrs:{id:"路由拦截"}},[e._v("路由拦截")]),n("p",[e._v("你需要先生成自己的  （"),n("strong",[e._v("[生成Token]")]),e._v("）。")]),n("p",[e._v("首先在定义路由的时候就需要多添加一个自定义字段"),n("code",[e._v("requireAuth")]),e._v("，用于判断该路由的访问是否需要登录。如果用户已经登录，则顺利进入路由， 否则就进入登录页面。")]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const routes = [\n    {\n        path: '/',\n        name: '/',\n        component: Index\n    },\n    {\n        path: '/repository',\n        name: 'repository',\n        meta: {\n            requireAuth: true,  // 添加该字段，表示进入这个路由是需要登录的\n        },\n        component: Repository\n    },\n    {\n        path: '/login',\n        name: 'login',\n        component: Login\n    }\n];\n")])])]),n("p",[e._v("定义完路由后，我们主要是利用"),n("code",[e._v("vue-router")]),e._v("提供的钩子函数"),n("code",[e._v("beforeEach()")]),e._v("对路由进行判断。")]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("router.beforeEach((to, from, next) => {\n    if (to.meta.requireAuth) {  // 判断该路由是否需要登录权限\n        if (store.state.token) {  // 通过vuex state获取当前的token是否存在\n            next();\n        }\n        else {\n            next({\n                path: '/login',\n                query: {redirect: to.fullPath}  // 将跳转的路由path作为参数，登录成功后跳转到该路由\n            })\n        }\n    }\n    else {\n        next();\n    }\n})\n")])])]),n("p",[e._v("每个钩子方法接收三个参数：")]),n("ul",[n("li",[e._v("to: Route: 即将要进入的目标 路由对象")]),n("li",[e._v("from: Route: 当前导航正要离开的路由")]),n("li",[e._v("next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。\n"),n("ul",[n("li",[e._v("next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。")]),n("li",[e._v("next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。")]),n("li",[e._v("next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。")])])])]),n("p",[n("strong",[e._v("确保要调用 next 方法，否则钩子就不会被 resolved。")])]),n("blockquote",[n("p",[e._v("完整的方法见"),n("code",[e._v("/src/router.js")])])]),n("p",[e._v("其中，"),n("code",[e._v("to.meta")]),e._v("中是我们自定义的数据，其中就包括我们刚刚定义的"),n("code",[e._v("requireAuth")]),e._v("字段。通过这个字段来判断该路由是否需要登录权限。需要的话，同时当前应用不存在token，则跳转到登录页面，进行登录。登录成功后跳转到目标路由。")]),n("p",[e._v("登录拦截到这里就结束了吗？并没有。这种方式只是简单的前端路由控制，并不能真正阻止用户访问需要登录权限的路由。还有一种情况便是：当前token失效了，但是token依然保存在本地。这时候你去访问需要登录权限的路由时，实际上应该让用户重新登录。 这时候就需要结合 http 拦截器 + 后端接口返回的http 状态码来判断。")]),n("h2",{attrs:{id:"拦截器"}},[e._v("拦截器")]),n("p",[e._v("要想统一处理所有http请求和响应，就得用上 axios 的拦截器。通过配置"),n("code",[e._v("http response inteceptor")]),e._v("，当后端接口返回"),n("code",[e._v("401 Unauthorized（未授权）")]),e._v("，让用户重新登录。")]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// http request 拦截器\naxios.interceptors.request.use(\n    config => {\n        if (store.state.token) {  // 判断是否存在token，如果存在的话，则每个http header都加上token\n            config.headers.Authorization = `token ${store.state.token}`;\n        }\n        return config;\n    },\n    err => {\n        return Promise.reject(err);\n    });\n\n// http response 拦截器\naxios.interceptors.response.use(\n    response => {\n        return response;\n    },\n    error => {\n        if (error.response) {\n            switch (error.response.status) {\n                case 401:\n                    // 返回 401 清除token信息并跳转到登录页面\n                    store.commit(types.LOGOUT);\n                    router.replace({\n                        path: 'login',\n                        query: {redirect: router.currentRoute.fullPath}\n                    })\n            }\n        }\n        return Promise.reject(error.response.data)   // 返回接口返回的错误信息\n    });\n")])])]),n("blockquote",[n("p",[e._v("完整的方法见"),n("code",[e._v("/src/http.js")]),e._v(".")])]),n("p",[e._v("通过上面这两步，就可以在前端实现登录拦截了。"),n("code",[e._v("登出")]),e._v("功能也就很简单，只需要把当前token清除，再跳转到首页即可。")]),n("p",[e._v("Now, let's try it 👉")])])}],!1,null,null,null);t.default=o.exports}}]);