(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{275:function(n,r,t){"use strict";t.r(r);var a=t(0),e=Object(a.a)({},(function(){var n=this.$createElement;this._self._c;return this._m(0)}),[function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"前端算法"}},[n._v("前端算法")]),t("h2",{attrs:{id:"冒泡排序-（bubble-sort）"}},[n._v("冒泡排序 （Bubble Sort）")]),t("p",[t("strong",[n._v("定义")])]),t("p",[n._v("冒泡排序（Bubble Sort）,它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。")]),t("p",[n._v("这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，所以叫“冒泡排序”。")]),t("p",[t("strong",[n._v("原理")])]),t("ol",[t("li",[n._v("比较相邻的元素。如果第一个比第二个大，就交换他们两个。")]),t("li",[n._v("对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。")]),t("li",[n._v("针对所有的元素重复以上的步骤，除了最后一个。")]),t("li",[n._v("持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。")])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('function bubbleSort(arr){\n  var i = 0,\n      j = 0;\n  for(i=1; i<arr.length; i++){\n    for(j=0; j<=arr.length-i; j++){\n      var temp = 0;\n      // ">" 从小到大排序\n      // "<" 从大到小排序\n      if(arr[j] > arr[j+1]){  //相邻元素两两对比\n        temp = arr[j];        //元素交换\n        arr[j] = arr[j+1];\n        arr[j+1] = temp;\n      }\n    }\n  }\n  return arr;\n}\n')])])]),t("h2",{attrs:{id:"选择排序（selection-sort）"}},[n._v("选择排序（Selection Sort）")]),t("p",[n._v("选择排序是一个简单直观的排序方法，它的工作")]),t("p",[n._v("**原理：**首先从未排序序列中找到最大的元素，放到已排序序列的末尾，重复上述步骤，直到所有元素排序完毕。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) { //寻找最小的数\n            \tminIndex = j; //将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    return arr;\n}\n")])])]),t("h2",{attrs:{id:"插入排序（insertion-sort）"}},[n._v("插入排序（Insertion Sort）")]),t("p",[n._v("插入排序是简单排序中最快的排序算法")]),t("p",[t("strong",[n._v("原理")]),n._v(" 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function insertionSort(arr) {\n    var len = arr.length;\n    var preIndex, current;\n    for (var i = 1; i < len; i++) {\n        preIndex = i - 1;\n        current = arr[i];\n        while(preIndex >= 0 && arr[preIndex] > current) {\n            arr[preIndex+1] = arr[preIndex];\n            preIndex--;\n        }\n        arr[preIndex+1] = current;\n    }\n    return arr;\n}\n")])])]),t("h2",{attrs:{id:"希尔排序（shell-sort）"}},[n._v("希尔排序（Shell Sort）")]),t("p",[n._v("希尔排序是插入排序的一种更高效率的实现。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function shellSort(arr) {\n    var N = arr.length;\n    var h = 1;\n    function swap(array, i, j) { //两个数调换\n        var temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n    while (h < N / 3) {\n        h = 3 * h + 1; //设置间隔\n    }\n    while (h >= 1) {\n        for (var i = h; i < N; i++) {\n            for (j = i; j >= h && arr[j] < arr[j - h]; j -= h) {\n                swap(arr, j, j - h);\n            }\n        }\n        h = (h - 1) / 3;\n    }\n    return arr;\n};\n")])])]),t("h2",{attrs:{id:"归并排序（merge-sort）"}},[n._v("归并排序（Merge Sort）")]),t("p",[n._v("其基本思想是分治策略，先进行划分，然后再进行合并。")]),t("ol",[t("li",[n._v("自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第2种方法）")]),t("li",[n._v("自下而上的迭代")])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function mergeSort(arr) { //采用自上而下的递归方法\n    var len = arr.length;\n    if (len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\nfunction merge(left, right) {\n    var result = [];\n    while (left.length > 0 && right.length > 0) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n    while (left.length)\n        result.push(left.shift());\n    while (right.length)\n        result.push(right.shift());\n    return result;\n}\n")])])]),t("h2",{attrs:{id:"快速排序-（quick-sort）"}},[n._v("快速排序 （Quick Sort）")]),t("p",[n._v("本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。")]),t("p",[n._v("处理大数据最快的排序算法之一了")]),t("p",[n._v("大致分三步：")]),t("p",[n._v("1、找基准（一般是以中间项为基准）")]),t("p",[n._v("2、遍历数组，小于基准的放在left，大于基准的放在right")]),t("p",[n._v("3、递归")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function quickSort(arr, left, right) {\n    function partition(arr, left, right) { //分区操作\n        var pivot = left, //设定基准值（pivot）\n            index = pivot + 1;\n        for (var i = index; i <= right; i++) {\n            if (arr[i] < arr[pivot]) {\n                swap(arr, i, index);\n                index++;\n            }\n        }\n        swap(arr, pivot, index - 1);\n        return index - 1;\n    }\n\n    function swap(arr, i, j) {\n        var temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    var len = arr.length,\n        partitionIndex,\n        left = typeof left != 'number' ? 0 : left,\n        right = typeof right != 'number' ? len - 1 : right;\n\n    if (left < right) {\n        partitionIndex = partition(arr, left, right);\n        quickSort(arr, left, partitionIndex - 1);\n        quickSort(arr, partitionIndex + 1, right);\n    }\n    return arr;\n};\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n")])])]),t("h2",{attrs:{id:"堆排序（heap-sort）"}},[n._v("堆排序（Heap Sort）")]),t("p",[n._v("堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：")]),t("ol",[t("li",[n._v("大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列")]),t("li",[n._v("小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列")])]),t("p",[n._v("**简单来说：**就是假如将此序列看成一棵完全二叉树，要使这个无序列表变成堆，则小于等于n/2(最后一个非终端节点就是n/2)的某个节点i的左右子节点均大于此节点。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n")])])]),t("h2",{attrs:{id:"计数排序（counting-sort）"}},[n._v("计数排序（Counting Sort）")]),t("p",[n._v("计数排序（Counting sort）是一种稳定的线性时间排序算法。\n计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。")]),t("p",[t("strong",[n._v("思路")])]),t("ol",[t("li",[n._v("找出待排序的数组中最大和最小的元素。")]),t("li",[n._v("统计数组中每个值为"),t("code",[n._v("i")]),n._v("的元素出现的次数，存入数组"),t("code",[n._v("C")]),n._v("的第"),t("code",[n._v("i")]),n._v("项。")]),t("li",[n._v("对所有的计数累加（从"),t("code",[n._v("C")]),n._v("中的第一个元素开始，每一项和前一项相加）。")]),t("li",[n._v("反向填充目标数组：将每个元素"),t("code",[n._v("i")]),n._v("放在新数组的第"),t("code",[n._v("C(i)")]),n._v("项，每放一个元素就将"),t("code",[n._v("C(i)")]),n._v("减去1。")])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function countingSort(iArr, max) {\n    var n = iArr.length;\n    var oArr = [];\n    // 创建长度max的数组，填充0\n    var C = [];\n    for (var i = 0; i <= max; i++) {\n        C[i] = 0;\n    }\n    // 遍历输入数组，填充C\n    for (var j = 0; j < n; j++) {\n        C[iArr[j]]++;\n    }\n    // 遍历C，输出数组\n    for (var k = 0; k <= max; k++) {\n        // 按顺序将值推入输出数组，并在比较后将对应标志位减1\n        while (C[k]-- > 0) {\n            oArr.push(k);\n        }\n    }\n    return oArr;\n}\n")])])]),t("h2",{attrs:{id:"桶排序（bucket-sort）"}},[n._v("桶排序（Bucket Sort）")]),t("p",[n._v("桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。\n为了使桶排序更加高效，我们需要做到这两点：")]),t("ol",[t("li",[n._v("在额外空间充足的情况下，尽量增大桶的数量")]),t("li",[n._v("使用的映射函数能够将输入的N个数据均匀的分配到K个桶中")])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function bucketSort(arr, bucketSize) {\n    if (arr.length === 0) {\n        return arr;\n    }\n    var i;\n    var minValue = arr[0];\n    var maxValue = arr[0];\n    for (i = 1; i < arr.length; i++) {\n        if (arr[i] < minValue) {\n            minValue = arr[i]; //输入数据的最小值\n        } else if (arr[i] > maxValue) {\n            maxValue = arr[i]; //输入数据的最大值\n        }\n    }\n    //桶的初始化\n    var DEFAULT_BUCKET_SIZE = 5; //设置桶的默认数量为5\n    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;\n    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;\n    var buckets = new Array(bucketCount);\n    for (i = 0; i < buckets.length; i++) {\n        buckets[i] = [];\n    }\n    //利用映射函数将数据分配到各个桶中\n    for (i = 0; i < arr.length; i++) {\n        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);\n    }\n    arr.length = 0;\n    for (i = 0; i < buckets.length; i++) {\n        insertionSort(buckets[i]); //对每个桶进行排序，这里使用了插入排序\n        for (var j = 0; j < buckets[i].length; j++) {\n            arr.push(buckets[i][j]);\n        }\n    }\n    return arr;\n}\nfunction insertionSort(arr) {\n    var len = arr.length;\n    var preIndex, current;\n    for (var i = 1; i < len; i++) {\n        preIndex = i - 1;\n        current = arr[i];\n        while (preIndex >= 0 && arr[preIndex] > current) {\n            arr[preIndex + 1] = arr[preIndex];\n            preIndex--;\n        }\n        arr[preIndex + 1] = current;\n    }\n    return arr;\n}\n")])])]),t("h2",{attrs:{id:"基数排序（radix-sort）"}},[n._v("基数排序（Radix Sort）")]),t("p",[n._v("基数排序有两种方法：")]),t("ol",[t("li",[n._v("MSD 从高位开始进行排序")]),t("li",[n._v("LSD 从低位开始进行排序")])]),t("p",[t("strong",[n._v("基数排序 vs 计数排序 vs 桶排序")])]),t("p",[n._v("这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：\n基数排序：根据键值的每位数字来分配桶\n计数排序：每个桶只存储单一键值\n桶排序：每个桶存储一定范围的数值")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function radixSort(arr, maxDigit) {\n    var counter = [];\n    var mod = 10;\n    var dev = 1;\n    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {\n        for(var j = 0; j < arr.length; j++) {\n            var bucket = parseInt((arr[j] % mod) / dev);\n            if(counter[bucket]==null) {\n                counter[bucket] = [];\n            }\n            counter[bucket].push(arr[j]);\n        }\n        var pos = 0;\n        for(var j = 0; j < counter.length; j++) {\n            var value = null;\n            if(counter[j]!=null) {\n                while ((value = counter[j].shift()) != null) {\n                      arr[pos++] = value;\n                }\n          }\n        }\n    }\n    return arr;\n};\n")])])]),t("h2",{attrs:{id:"判断文本是否为回文"}},[n._v("判断文本是否为回文")]),t("p",[n._v("定义：如果将一个文本翻转过来，能和原文本完全相等，那么就可以称之为“回文”。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('/**\n* @param {string|number} [value] [需要判断的文字]\n* @return {boolean} [布尔值]\n*/\n\nfunction isPalindrome(value) {\n    var value = value.toString();\n    var _value = value.split("").reverse().join("");\n    return value === _value;\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n* @param {string|number} [value] [需要判断的文字]\n* @return {boolean} [布尔值]\n*/\nfunction isPalindrome(val) {\n    var val = val.toString();\n    // 这 i < j ,中间只有一个字符，不需要比较\n    for (let i = 0, j = val.length - 1; i < j; i++, j--) {\n        if (val.charAt(i) !== val.charAt(j)) {\n            return false;\n        }\n    }\n    return true;\n}\n")])])]),t("h2",{attrs:{id:"斐波那契数列"}},[n._v("斐波那契数列")]),t("p",[n._v("定义：指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........")]),t("p",[n._v("数列从第3项开始，每一项都等于前两项之和。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function fib(n){\n\tif(n === 1 || n === 2){\n\t\treturn 1;\n\t}\n\treturn fib(n - 1) + fib(n - 2);\n}\n//PS：时间复杂度为O(2^n)，空间复杂度为O(n)\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function fib(n){\n\tlet tem = [1, 1];\n\tif(n === 1 || n === 2){\n\t\treturn 1;\n\t}\n\t// 数组索引从0开始，数列索引从1开始\n\tfor(let i = 2; i < n; i++){\n\t\ttem[i] = tem[i-1] + tem[i-2];\n\t}\n\treturn tem[n-1];\n}\n//PS：时间复杂度为O(n)，空间复杂度为O(n)\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function fib(n){\n\tlet prev = 1, \n\t\tnext = 1,\n\t\tres;\n\tfor(let i = 2; i < n; i++){\n\t\tres = prev + next;  \n\t\tprev = next; \n\t\tnext = res;\n\t}\t\n\treturn res;\n}\n//PS：时间复杂度为O(n)，空间复杂度为O(1)\n")])])]),t("h2",{attrs:{id:"阶乘"}},[n._v("阶乘")]),t("p",[n._v("定义：一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且0的阶乘为1。自然数n的阶乘写作n!。")]),t("p",[n._v("任何大于等于1 的自然数n 阶乘表示方法：n！=n*(n-1)!  或  n！=1X2X3X...(n-1)n")]),t("p",[n._v("0! = 1;")]),t("ol",[t("li",[t("p",[n._v("递归")]),t("p",[n._v("计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。")]),t("p",[n._v("递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function factorialize(num) {\n    if (typeof n !== 'number') throw new Error('参数必须为整数')\n    if (n === 1) return 1;\n    return num * factorialize(num - 1)\n}\n")])])])]),t("li",[t("p",[n._v("ES6尾调用（递归优化版）")]),t("p",[n._v("只存在一个调用帧，不会发生“栈溢出”错误。")]),t("p",[n._v("尾调用（Tail Call）是函数式编程的一个重要概念，就是指某个函数的最后一步是调用另一个函数。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function factorialize(n, total = 1) {\n    if (typeof n !== 'number' || typeof total !== 'number') throw new Error('参数必须为整整')\n    if (n === 1) return total;\n    console.log(n, total, n * total)\n    return factorialize(n - 1, n * total)\n}\n")])])])]),t("li",[t("p",[n._v("循环计算")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function factorialize(n) {\n    if (typeof n !== 'number') throw new Error('参数必须为整数')\n    if (n === 1) return 1;\n    let total = 1;\n    while (n > 1) {\n        total = n * total;\n        n--;\n    }\n    return total;\n}\n")])])])])]),t("h2",{attrs:{id:"随机生成长度为n字符串"}},[n._v("随机生成长度为n字符串")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * @param  {number} num    需要生成字符串个数\n * @return {string} res    生成的字符串返回值\n */\nfunction randomString(num){\n\tlet str = 'abcdefghijklmnopqrstuvwxyz0123456789';\n\tlet res = '',\n\t\ti = 0;\n\t// Math.random 函数产生值的范围[0,1)\n\twhile(i<num){\n\t\tres += str.charAt(Math.floor(Math.random() * str.length))\n\t\ti++;\n\t}\n\t\n\treturn res;\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("PS:ASCII\n/**\n * @param  {number} num    需要生成字符串个数\n * @return {string} res    生成的字符串返回值\n */\nfunction randomString(num) {\n    let res = '';\n    function randomChar() {\n        let l = Math.floor(Math.random() * 62);\n        if (l < 10) return l; // 数字部分 0-9\n        if (l < 36) return String.fromCharCode(l + 55); // 大写字母\n        return String.fromCharCode(l + 61); // 小写字母\n    }\n    while (res.length < num) res += randomChar();\n    return res;\n}\nconsole.log(randomString(8))\n")])])]),t("h2",{attrs:{id:"出现最多的字符及次数"}},[n._v("出现最多的字符及次数")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * 利用json数据个数“键”唯一的特性\n * @param  {string} str    需要查找的字符串\n * @return {object} {}     返回的出现最多的字符串及次数\n */\nfunction maxN(str) {\n\tif(typeof(str) !== 'string') str = str.toString();\n    //json对象用于保存str的每一项以及出现次数。\n    var json = {};\n    for (var i = 0; i < str.length; i++) {\n        if (!json[str.charAt(i)]) {\n            json[str.charAt(i)] = 1;\n        } else {\n            json[str.charAt(i)]++;\n        }\n    }\n    //存储出现次数最多的值和次数\n    var number = '';\n    var num = 0;\n    console.log(json)\n    //遍历json  使用打擂算法统计需要的值\n    for (var j in json) {\n        if (json[j] > num) {\n            num = json[j];\n            number = j;\n        }\n    }\n    return {\n        number: number,\n        num: num\n    }\n}\n")])])]),t("h2",{attrs:{id:"扁平化数组"}},[n._v("扁平化数组")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * 递归调用\n * @param {array} [arr] [扁平化数组]\n * @return {array} [res]\n */\nfunction flatten(arr) {\n    let res = [],\n        i = 0,\n        len = arr.length;\n    while (i < len) {\n        if (Array.isArray(arr[i])) {\n            // 递归进行上面步骤\n            // [].concat(...arr)，它的参数可以为数组或值，作用为将数组或值连接成新数组。\n            res = res.concat(flatten(arr[i]))\n        } else {\n            res.push(arr[i]);\n        }\n        i++;\n    }\n    return res;\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * reduce+concat\n * @param {array} [arr] [扁平化数组]\n */\nfunction flatten(arr) {\n    return arr.reduce((pre, cut) => {\n        return pre.concat(Array.isArray(cut) ? flatten(cut) : cut)\n    }, [])\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * 转换成字符串\n * @param {array} [arr] [扁平化数组]\n */\n\nfunction flatten(arr) {\n    return arr.toString().split(',')\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("/**\n * 只能处理2维数组。\n * 转换成字符串\n * @param {array} [arr] [扁平化数组]\n */\nfunction flatten(arr) {\n    let _arr = [];\n    arr.forEach(item => {\n        if (Array.isArray(item)) {\n            _arr = _arr.concat(...item)\n        } else {\n            _arr = _arr.concat(item)\n        }\n    })\n    return _arr;\n}\n")])])]),t("h2",{attrs:{id:"数组中最大差值"}},[n._v("数组中最大差值")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function getMaxProfit(arr){\n\treturn Math.max.apply(null, arr) - Math.min.apply(null, arr);\n}\n")])])]),t("h2",{attrs:{id:"是否为质数（素数）"}},[n._v("是否为质数（素数）")]),t("p",[n._v("质数：只能被1和自己整除且大于1的数。\n合数：数大于1且因数多余2个（大于1的数质数的补集）。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function isPrimeNumber(n) {\n    if (n < 2) return false;\n    if (n === 2) return true; // 最小的质数\n    for (let i = 2; i < n; i++) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function isPrimeNumber1(n){\n  return n<2?false:!/^(11+?)\\1+$/.test(Array(n+1).join('1'))\n}\n")])])]),t("p",[n._v("Now, let's try it 👉")])])}],!1,null,null,null);r.default=e.exports}}]);