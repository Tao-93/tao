(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{247:function(e,t,n){e.exports=n.p+"assets/img/js_15.feb1d07d.png"},312:function(e,t,n){"use strict";n.r(t);var s=[function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("首先可以通过 "),t("strong",[this._v("Object.assign")]),this._v("来解决这个问题。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("let a = {\n    age: 1\n}\nlet b = Object.assign({}, a)\na.age = 2\nconsole.log(b.age) // 1\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("let a = {\n    age: 1\n}\nlet b = {...a}\na.age = 2\nconsole.log(b.age) // 1\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("let a = {\n    age: 1,\n    jobs: {\n        first: 'FE'\n    }\n}\nlet b = {...a}\na.jobs.first = 'native'\nconsole.log(b.jobs.first) // native\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("这个问题通常可以通过 "),t("strong",[this._v("JSON.parse(JSON.stringify(object))")]),this._v(" 来解决。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("let a = {\n    age: 1,\n    jobs: {\n        first: 'FE'\n    }\n}\nlet b = JSON.parse(JSON.stringify(a))\na.jobs.first = 'native'\nconsole.log(b.jobs.first) // FE\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("会忽略 "),t("code",[this._v("undefined")])]),t("li",[this._v("不能序列化函数")]),t("li",[this._v("不能解决循环引用的对象")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("let obj = {\n  a: 1,\n  b: {\n    c: 2,\n    d: 3,\n  },\n}\nobj.c = obj.b\nobj.e = obj.a\nobj.b.c = obj.c\nobj.b.d = obj.b\nobj.b.e = obj.b.c\nlet newObj = JSON.parse(JSON.stringify(obj))\nconsole.log(newObj)\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:n(247),alt:"img"}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("在遇到函数或者 "),t("code",[this._v("undefined")]),this._v(" 的时候，该对象也不能正常的序列化")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("let a = {\n    age: undefined,\n    jobs: function() {},\n    name: 'yck'\n}\nlet b = JSON.parse(JSON.stringify(a))\nconsole.log(b) // {name: \"yck\"}\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("你会发现在上述情况中，该方法会忽略掉函数和 "),t("code",[this._v("undefined")]),this._v(" 。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 "),t("code",[this._v("MessageChannel")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("function structuralClone(obj) {\n  return new Promise(resolve => {\n    const {port1, port2} = new MessageChannel();\n    port2.onmessage = ev => resolve(ev.data);\n    port1.postMessage(obj);\n  });\n}\n\nvar obj = {a: 1, b: {\n    c: b\n}}\n// 注意该方法是异步的\n// 可以处理 undefined 和循环引用对象\nconst clone = await structuralClone(obj);\n")])])])}],a=n(0),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"深浅拷贝"}},[e._v("深浅拷贝")]),n("h2",{attrs:{id:"浅拷贝"}},[e._v("浅拷贝")]),e._m(0),e._m(1),n("p",[e._v("当然我们也可以通过**展开运算符（…）**来解决")]),e._m(2),n("p",[e._v("通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了")]),e._m(3),n("p",[e._v("浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷贝。")]),n("h2",{attrs:{id:"深拷贝"}},[e._v("深拷贝")]),e._m(4),e._m(5),n("p",[e._v("但是该方法也是有局限性的：")]),e._m(6),e._m(7),n("p",[e._v("如果你有这么一个循环引用对象，你会发现你不能通过该方法深拷贝")]),e._m(8),e._m(9),e._m(10),e._m(11),n("p",[e._v("但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 "),n("a",{attrs:{href:"https://lodash.com/docs##cloneDeep",target:"_blank",rel:"noopener noreferrer"}},[e._v("lodash 的深拷贝函数"),n("OutboundLink")],1),e._v("。")]),e._m(12),e._m(13),n("p",[e._v("Now, let's try it 👉")])])}),s,!1,null,null,null);t.default=r.exports}}]);