(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{306:function(n,t,e){"use strict";e.r(t);var o=e(0),c=Object(o.a)({},(function(){var n=this.$createElement;this._self._c;return this._m(0)}),[function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"处理异步的方法"}},[n._v("处理异步的方法")]),e("h3",{attrs:{id:"回调函数-callback"}},[n._v("回调函数--callback")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function fn1 () {\n  console.log('Function 1')\n}\n \nfunction fn2 () {\n  setTimeout(() => {\n    console.log('Function 2')\n  }, 500)\n}\n \nfunction fn3 () {\n  console.log('Function 3')\n}\n")])])]),e("h3",{attrs:{id:"发布-订阅"}},[n._v("发布/订阅")]),e("p",[n._v('我们假定，存在一个"信号中心"，某个任务执行完成，就向信号中心"发布"（publish）一个信号，其他任务可以向信号中心"订阅"（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做["发布/订阅模式"]（publish-subscribe pattern），又称["观察者模式"])（observer pattern）。')]),e("p",[n._v("例："),e("code",[n._v("fn1")]),n._v("，"),e("code",[n._v("fn2")]),n._v("，"),e("code",[n._v("fn3")]),n._v("都可以视作一个事件的发布者，只要执行它，就会发布一个事件。这个时候，我们可以通过一个事件的订阅者去批量订阅并处理这些事件，包括它们的先后顺序")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("\nclass AsyncFunArr {\n  constructor (...arr) {\n      this.funcArr = [...arr]\n  }\n \n  next () {\n      const fn = this.funcArr.shift()\n      if (typeof fn === 'function') fn()\n  }\n \n  run () {\n      this.next()\n  }\n}\n \nconst asyncFunArr = new AsyncFunArr(fn1, fn2, fn3)\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function fn1 () {\n  console.log('Function 1')\n  asyncFunArr.next()\n}\n \nfunction fn2 () {\n  setTimeout(() => {\n    console.log('Function 2')\n    asyncFunArr.next()\n  }, 500)\n}\n \nfunction fn3 () {\n  console.log('Function 3')\n  asyncFunArr.next()\n}\n \n// output =>\n// Function 1\n// Function 2\n// Function 3\n")])])]),e("p",[n._v("可以看到，函数的处理顺序等于传入"),e("code",[n._v("AsyncFunArr")]),n._v("的参数顺序。"),e("code",[n._v("AsyncFunArr")]),n._v("在内部维护一个数组，每一次调用"),e("code",[n._v("next()")]),n._v("方法都会按顺序推出数组所保存的一个对象并执行，这也是我在实际的工作中比较常用的方法。")]),e("h3",{attrs:{id:"promise"}},[n._v("promise")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("\nfunction fn1 () {\n  console.log('Function 1')\n}\n \nfunction fn2 () {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('Function 2')\n      resolve()\n    }, 500)\n  })\n}\n \nfunction fn3 () {\n  console.log('Function 3')\n}\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("\nfn1()\nfn2().then(() => { fn3() })\n \n// output =>\n// Function 1\n// Function 2\n// Function 3\n")])])]),e("h3",{attrs:{id:"generator"}},[n._v("generator")]),e("p",[n._v("generator的办法则可以消灭那一大堆的Promise特征方法，比如一大堆的"),e("code",[n._v("then()")]),n._v("。")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function fn1 () {\n  console.log('Function 1')\n}\n \nfunction fn2 () {\n  setTimeout(() => {\n    console.log('Function 2')\n    af.next()\n  }, 500)\n}\n \nfunction fn3 () {\n  console.log('Function 3')\n}\n \nfunction* asyncFunArr (...fn) {\n  fn[0]()\n  yield fn[1]()\n  fn[2]()\n}\n \nconst af = asyncFunArr(fn1, fn2, fn3)\n \naf.next()\n \n// output =>\n// Function 1\n// Function 2\n// Function 3\n")])])]),e("p",[n._v("generator函数"),e("code",[n._v("asyncFunArr()")]),n._v("接受一个待执行函数列表"),e("code",[n._v("fn")]),n._v("，异步函数将会通过"),e("code",[n._v("yield")]),n._v("来执行。在异步函数内，通过"),e("code",[n._v("af.next()")]),n._v("激活generator函数的下一步操作。")]),e("h3",{attrs:{id:"async-await"}},[n._v("async/await")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function fn1 () {\n  console.log('Function 1')\n}\n \nfunction fn2 () {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('Function 2')\n      resolve()\n    }, 500)\n  })\n}\n \nfunction fn3 () {\n  console.log('Function 3')\n}\n \nasync function asyncFunArr () {\n  fn1()\n  await fn2()\n  fn3()\n}\n \nasyncFunArr()\n \n// output =>\n// Function 1\n// Function 2\n// Function 3\n")])])]),e("p",[n._v("Now, let's try it 👉")])])}],!1,null,null,null);t.default=c.exports}}]);