(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{290:function(e,n,t){"use strict";t.r(n);var a=t(0),s=Object(a.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"组件通信"}},[e._v("组件通信")]),t("h2",{attrs:{id:"_1-父组件是通过props传递数据给子组件"}},[e._v("1.父组件是通过props传递数据给子组件")]),t("p",[e._v("v-model 中包含了两个子组件")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<div class="w-base">\n    <book-component v-bind:bookdata="book"></book-component>\n</div>\n\n<div class="base">\n    <node-component v-bind:catalog="catalog" ></node-component>\n</div>\n')])])]),t("p",[e._v("在上面这段代码中我们可以看到，定义了两个子组件，并且使用指定v-bind指令传递了数据，子组件会接收到传递的数据。")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.component('book-component', {\n  template: tpl,//可以传进来子组件的模板文件\n  props: ['book'],\n  data: function () {\n    return { myBook: this.bookdata }\n  }\n})\n")])])]),t("p",[e._v("建议接收到单向的props数据后，定义一个局部变量来初始化使用。")]),t("h2",{attrs:{id:"_2-父组件与子组件之间通信的其他方式"}},[e._v("2.父组件与子组件之间通信的其他方式")]),t("p",[e._v("vue中给实例提供了三个我们可用的API"),t("code",[e._v("$children")]),e._v("和"),t("code",[e._v("$refs")]),e._v("以及"),t("code",[e._v("$parent")]),e._v("。")]),t("p",[t("code",[e._v("$children")]),e._v("：当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的。")]),t("p",[t("code",[e._v("$refs")]),e._v("：包含了当前实例所有拥有 "),t("code",[e._v("ref")]),e._v(" 注册的子组件的对象.")]),t("p",[t("code",[e._v("$parent")]),e._v(": 当前实例的父实例。")]),t("p",[e._v("所以说，如果在通信方面我们我组件想要调用子组件，能用的方法只有"),t("code",[e._v("$refs")]),e._v("了，因为"),t("code",[e._v("$children")]),e._v("是一个数组，并且不保证顺序，也没有相关的id去寻找我们需要的那个特定子组件。但是如果使用"),t("code",[e._v("$refs")]),e._v("去寻找特定子组件，那就必须要给那个子组件注册"),t("code",[e._v("ref")]),e._v("。")]),t("p",[e._v("父组件的模版")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\x3c!-- vm.$refs.child will be the child comp instance --\x3e\n<child-component ref="child"></child-comp>\n')])])]),t("p",[e._v("父组件")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//找到子组件并且调用它的方法\nvar myChild = this.$refs.child;\nmyChild.func();\n")])])]),t("p",[e._v("子组件")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//找到父组件并且调用它的方法\nvar myParent = this.$parent;\nmyParent.func();\n")])])]),t("h2",{attrs:{id:"_3-子组件向父组件传数据"}},[e._v("3.子组件向父组件传数据")]),t("p",[e._v("vm.$emit( event, arg ) ----------触发当前实例上的事件")]),t("p",[e._v("vm.$on( event, fn )----------------监听event事件后运行 fn")]),t("p",[e._v("父组件")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<template lang=\"pug\">\n  div\n    demo(:msg=\"msg\" v-on:changeMsg='onChange')\n</template>\n\n<script>\nimport Demo from './demo.vue'\nexport default {\n  data () {\n    return {\n      msg: '首次数据传递'\n    }\n  },\n  components: {\n    Demo\n  },\n  methods: {\n    onChange (msg) {\n      this.msg = msg\n    }\n  }\n}\n<\/script>\n")])])]),t("p",[e._v("我们随后把demo引入，传入子组件的msg我们事先在data数据里面定义好，同时在demo组件上进行一个$on的监听")]),t("p",[e._v("子组件")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<template lang=\"pug\">\n  .demo\n    .demo-example(@click=\"changePropsValue\") {{msg}}\n</template>\n<script>\nexport default {\n  props: ['msg'],\n  methods: {\n    changePropsValue () {\n      this.$emit('changeMsg', '通过$emit触发事件了')\n    }\n  }\n}\n<\/script>复制代码\n")])])]),t("p",[e._v("1.msg是通过父组件传递过来的，我们先前可肯定要在props里声明好\n2.在点击的时候，我们触发了changeMsg事件，第二个参数是，你想要传到父组件的参数")]),t("h2",{attrs:{id:"_4-平行组件之间的两种通信方式"}},[e._v("4.平行组件之间的两种通信方式")]),t("p",[e._v("a.官方提供的事件bus")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var bus = new Vue()\n// 触发组件 A 中的事件\nbus.$emit('id-selected', 1)\n// 在组件 B 创建的钩子中监听事件\nbus.$on('id-selected', function (id) {\n  // ...\n})\n")])])]),t("p",[e._v("b.通过父组件去找兄弟组件")]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//找到父组件的$refs对象，然后找到组件的兄弟组件\n var $refs = this.$parent?this.$parent.$refs:{};\n var childComponent =  $refs.child; //child为改组件的ref属性值\n")])])]),t("blockquote",[t("p",[e._v("其实以上两种方法最好的实践方式是封装到项目的基类中，这样不用每次都去定义一个空Vue()实例，而是每个实例的基类中都有这个事件bus。同样可以封装找到其他兄弟组件的方法，但是该兄弟组件必须注册ref")])]),t("p",[t("strong",[e._v("下面这个方法是我在项目中封装的用于找到父组件，然后再去找到兄弟组件的方法。")])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//平行组件之间的通信\ngetComponentByRef: function(refId) {\n    var $refs = this.$parent?this.$parent.$refs:{};\n    for (var $id in $refs) {\n        if ($id == refId) {\n            return $refs[$id];\n        }\n    }\n    return null;\n}\n")])])]),t("p",[t("strong",[e._v("使用")])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//在组件中直接使用\nthis.getComponentByRef("booknode").updateNode(this.node);\n')])])]),t("h2",{attrs:{id:"_5-组件间复杂数据通信vuex"}},[e._v("5.组件间复杂数据通信Vuex")]),t("p",[e._v("一说到vuex，很多刚开始接触vue的人会主动避免去使用它，其实它并没有想象中的那么复杂。最好的开始是引入vuex后，走一遍给出的小示例。但是如果你的项目并不复杂的话，可以不考虑状态管理，那么什么时候需要使用状态管理呢？")]),t("p",[e._v("我们来看这样一个布局")]),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2017/8/14/23c1698327a549f86c524a6f5038bb91?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),t("p",[e._v("如果component1中的某个数据变更，那么com2,com3也要跟着更新，此时com3中又细分为了三个小组件。")]),t("p",[e._v("问题：")]),t("ol",[t("li",[e._v("多个试图依赖同一个状态")]),t("li",[e._v("多层嵌套的组件，数据变更和代码维护困难")])]),t("p",[e._v("Now, let's try it 👉")])])}],!1,null,null,null);n.default=s.exports}}]);