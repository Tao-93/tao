(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{230:function(n,e,t){n.exports=t.p+"assets/img/vue_02.5b4ddc25.png"},283:function(n,e,t){"use strict";t.r(e);var r=[function(){var n=this,e=n.$createElement,r=n._self._c||e;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"vuerouter"}},[n._v("VueRouter")]),r("h3",{attrs:{id:"é‡è¦å‡½æ•°æ€ç»´å¯¼å›¾"}},[n._v("é‡è¦å‡½æ•°æ€ç»´å¯¼å›¾")]),r("p",[n._v("ä»¥ä¸‹æ€ç»´å¯¼å›¾ç½—åˆ—äº†æºç ä¸­é‡è¦çš„ä¸€äº›å‡½æ•° "),r("img",{attrs:{src:t(230),alt:"img"}})]),r("h2",{attrs:{id:"è·¯ç”±æ³¨å†Œ"}},[n._v("è·¯ç”±æ³¨å†Œ")]),r("p",[n._v("åœ¨å¼€å§‹ä¹‹å‰ï¼Œæ¨èå¤§å®¶ clone ä¸€ä»½æºç å¯¹ç…§ç€çœ‹ã€‚å› ä¸ºç¯‡å¹…è¾ƒé•¿ï¼Œå‡½æ•°é—´çš„è·³è½¬ä¹Ÿå¾ˆå¤šã€‚")]),r("p",[n._v("ä½¿ç”¨è·¯ç”±ä¹‹å‰ï¼Œéœ€è¦è°ƒç”¨ "),r("code",[n._v("Vue.use(VueRouter)")]),n._v("ï¼Œè¿™æ˜¯å› ä¸ºè®©æ’ä»¶å¯ä»¥ä½¿ç”¨ Vue")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("export function initUse (Vue: GlobalAPI) {\n  Vue.use = function (plugin: Function | Object) {\n    // åˆ¤æ–­é‡å¤å®‰è£…æ’ä»¶\n    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n    const args = toArray(arguments, 1)\n    // æ’å…¥ Vue\n    args.unshift(this)\n    // ä¸€èˆ¬æ’ä»¶éƒ½ä¼šæœ‰ä¸€ä¸ª install å‡½æ•°\n    // é€šè¿‡è¯¥å‡½æ•°è®©æ’ä»¶å¯ä»¥ä½¿ç”¨ Vue\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args)\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args)\n    }\n    installedPlugins.push(plugin)\n    return this\n  }\n}\n")])])]),r("p",[n._v("æ¥ä¸‹æ¥çœ‹ä¸‹ "),r("code",[n._v("install")]),n._v(" å‡½æ•°çš„éƒ¨åˆ†å®ç°")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("export function install (Vue) {\n  // ç¡®ä¿ install è°ƒç”¨ä¸€æ¬¡\n  if (install.installed && _Vue === Vue) return\n  install.installed = true\n  // æŠŠ Vue èµ‹å€¼ç»™å…¨å±€å˜é‡\n  _Vue = Vue\n  const registerInstance = (vm, callVal) => {\n    let i = vm.$options._parentVnode\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal)\n    }\n  }\n  // ç»™æ¯ä¸ªç»„ä»¶çš„é’©å­å‡½æ•°æ··å…¥å®ç°\n  // å¯ä»¥å‘ç°åœ¨ `beforeCreate` é’©å­æ‰§è¡Œæ—¶\n  // ä¼šåˆå§‹åŒ–è·¯ç”±\n  Vue.mixin({\n    beforeCreate () {\n      // åˆ¤æ–­ç»„ä»¶æ˜¯å¦å­˜åœ¨ router å¯¹è±¡ï¼Œè¯¥å¯¹è±¡åªåœ¨æ ¹ç»„ä»¶ä¸Šæœ‰\n      if (isDef(this.$options.router)) {\n        // æ ¹è·¯ç”±è®¾ç½®ä¸ºè‡ªå·±\n        this._routerRoot = this\n        this._router = this.$options.router\n        // åˆå§‹åŒ–è·¯ç”±\n        this._router.init(this)\n        // å¾ˆé‡è¦ï¼Œä¸º _route å±æ€§å®ç°åŒå‘ç»‘å®š\n        // è§¦å‘ç»„ä»¶æ¸²æŸ“\n        Vue.util.defineReactive(this, '_route', this._router.history.current)\n      } else {\n        // ç”¨äº router-view å±‚çº§åˆ¤æ–­\n        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this\n      }\n      registerInstance(this, this)\n    },\n    destroyed () {\n      registerInstance(this)\n    }\n  })\n  // å…¨å±€æ³¨å†Œç»„ä»¶ router-link å’Œ router-view\n  Vue.component('RouterView', View)\n  Vue.component('RouterLink', Link)\n}\n")])])]),r("p",[n._v("å¯¹äºè·¯ç”±æ³¨å†Œæ¥è¯´ï¼Œæ ¸å¿ƒå°±æ˜¯è°ƒç”¨ "),r("code",[n._v("Vue.use(VueRouter)")]),n._v("ï¼Œä½¿å¾— VueRouter å¯ä»¥ä½¿ç”¨ Vueã€‚ç„¶åé€šè¿‡ Vue æ¥è°ƒç”¨ VueRouter çš„ "),r("code",[n._v("install")]),n._v(" å‡½æ•°ã€‚åœ¨è¯¥å‡½æ•°ä¸­ï¼Œæ ¸å¿ƒå°±æ˜¯ç»™ç»„ä»¶æ··å…¥é’©å­å‡½æ•°å’Œå…¨å±€æ³¨å†Œä¸¤ä¸ªè·¯ç”±ç»„ä»¶ã€‚")]),r("h2",{attrs:{id:"vuerouterå®ä¾‹åŒ–"}},[n._v("VueRouterå®ä¾‹åŒ–")]),r("p",[n._v("åœ¨å®‰è£…æ’ä»¶åï¼Œå¯¹ VueRouter è¿›è¡Œå®ä¾‹åŒ–ã€‚")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const Home = { template: '<div>home</div>' }\nconst Foo = { template: '<div>foo</div>' }\nconst Bar = { template: '<div>bar</div>' }\n\n// 3. Create the router\nconst router = new VueRouter({\n  mode: 'hash',\n  base: __dirname,\n  routes: [\n    { path: '/', component: Home }, // all paths are defined without the hash.\n    { path: '/foo', component: Foo },\n    { path: '/bar', component: Bar }\n  ]\n})\n")])])]),r("p",[n._v("æ¥çœ‹ä¸€ä¸‹ VueRouter çš„æ„é€ å‡½æ•°")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("constructor(options: RouterOptions = {}) {\n    // ...\n    // è·¯ç”±åŒ¹é…å¯¹è±¡\n    this.matcher = createMatcher(options.routes || [], this)\n\n    // æ ¹æ® mode é‡‡å–ä¸åŒçš„è·¯ç”±æ–¹å¼\n    let mode = options.mode || 'hash'\n    this.fallback =\n      mode === 'history' && !supportsPushState && options.fallback !== false\n    if (this.fallback) {\n      mode = 'hash'\n    }\n    if (!inBrowser) {\n      mode = 'abstract'\n    }\n    this.mode = mode\n\n    switch (mode) {\n      case 'history':\n        this.history = new HTML5History(this, options.base)\n        break\n      case 'hash':\n        this.history = new HashHistory(this, options.base, this.fallback)\n        break\n      case 'abstract':\n        this.history = new AbstractHistory(this, options.base)\n        break\n      default:\n        if (process.env.NODE_ENV !== 'production') {\n          assert(false, `invalid mode: ${mode}`)\n        }\n    }\n  }\n")])])]),r("p",[n._v("åœ¨å®ä¾‹åŒ– VueRouter çš„è¿‡ç¨‹ä¸­ï¼Œæ ¸å¿ƒæ˜¯åˆ›å»ºä¸€ä¸ªè·¯ç”±åŒ¹é…å¯¹è±¡ï¼Œå¹¶ä¸”æ ¹æ® mode æ¥é‡‡å–ä¸åŒçš„è·¯ç”±æ–¹å¼ã€‚")]),r("h2",{attrs:{id:"åˆ›å»ºè·¯ç”±åŒ¹é…å¯¹è±¡"}},[n._v("åˆ›å»ºè·¯ç”±åŒ¹é…å¯¹è±¡")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("export function createMatcher (\n  routes: Array<RouteConfig>,\n  router: VueRouter\n): Matcher {\n    // åˆ›å»ºè·¯ç”±æ˜ å°„è¡¨\n  const { pathList, pathMap, nameMap } = createRouteMap(routes)\n    \n  function addRoutes (routes) {\n    createRouteMap(routes, pathList, pathMap, nameMap)\n  }\n  // è·¯ç”±åŒ¹é…\n  function match (\n    raw: RawLocation,\n    currentRoute?: Route,\n    redirectedFrom?: Location\n  ): Route {\n    //...\n  }\n\n  return {\n    match,\n    addRoutes\n  }\n}\n")])])]),r("p",[r("code",[n._v("createMatcher")]),n._v(" å‡½æ•°çš„ä½œç”¨å°±æ˜¯åˆ›å»ºè·¯ç”±æ˜ å°„è¡¨ï¼Œç„¶åé€šè¿‡é—­åŒ…çš„æ–¹å¼è®© "),r("code",[n._v("addRoutes")]),n._v(" å’Œ "),r("code",[n._v("match")]),n._v(" å‡½æ•°èƒ½å¤Ÿä½¿ç”¨è·¯ç”±æ˜ å°„è¡¨çš„å‡ ä¸ªå¯¹è±¡ï¼Œæœ€åè¿”å›ä¸€ä¸ª "),r("code",[n._v("Matcher")]),n._v(" å¯¹è±¡ã€‚")]),r("p",[n._v("æ¥ä¸‹æ¥çœ‹ "),r("code",[n._v("createMatcher")]),n._v(" å‡½æ•°æ—¶å¦‚ä½•åˆ›å»ºæ˜ å°„è¡¨çš„")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("export function createRouteMap (\n  routes: Array<RouteConfig>,\n  oldPathList?: Array<string>,\n  oldPathMap?: Dictionary<RouteRecord>,\n  oldNameMap?: Dictionary<RouteRecord>\n): {\n  pathList: Array<string>;\n  pathMap: Dictionary<RouteRecord>;\n  nameMap: Dictionary<RouteRecord>;\n} {\n  // åˆ›å»ºæ˜ å°„è¡¨\n  const pathList: Array<string> = oldPathList || []\n  const pathMap: Dictionary<RouteRecord> = oldPathMap || Object.create(null)\n  const nameMap: Dictionary<RouteRecord> = oldNameMap || Object.create(null)\n  // éå†è·¯ç”±é…ç½®ï¼Œä¸ºæ¯ä¸ªé…ç½®æ·»åŠ è·¯ç”±è®°å½•\n  routes.forEach(route => {\n    addRouteRecord(pathList, pathMap, nameMap, route)\n  })\n  // ç¡®ä¿é€šé…ç¬¦åœ¨æœ€å\n  for (let i = 0, l = pathList.length; i < l; i++) {\n    if (pathList[i] === '*') {\n      pathList.push(pathList.splice(i, 1)[0])\n      l--\n      i--\n    }\n  }\n  return {\n    pathList,\n    pathMap,\n    nameMap\n  }\n}\n// æ·»åŠ è·¯ç”±è®°å½•\nfunction addRouteRecord (\n  pathList: Array<string>,\n  pathMap: Dictionary<RouteRecord>,\n  nameMap: Dictionary<RouteRecord>,\n  route: RouteConfig,\n  parent?: RouteRecord,\n  matchAs?: string\n) {\n  // è·å¾—è·¯ç”±é…ç½®ä¸‹çš„å±æ€§\n  const { path, name } = route\n  const pathToRegexpOptions: PathToRegexpOptions = route.pathToRegexpOptions || {}\n  // æ ¼å¼åŒ– urlï¼Œæ›¿æ¢ / \n  const normalizedPath = normalizePath(\n    path,\n    parent,\n    pathToRegexpOptions.strict\n  )\n  // ç”Ÿæˆè®°å½•å¯¹è±¡\n  const record: RouteRecord = {\n    path: normalizedPath,\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n    components: route.components || { default: route.component },\n    instances: {},\n    name,\n    parent,\n    matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null\n      ? {}\n      : route.components\n        ? route.props\n        : { default: route.props }\n  }\n\n  if (route.children) {\n    // é€’å½’è·¯ç”±é…ç½®çš„ children å±æ€§ï¼Œæ·»åŠ è·¯ç”±è®°å½•\n    route.children.forEach(child => {\n      const childMatchAs = matchAs\n        ? cleanPath(`${matchAs}/${child.path}`)\n        : undefined\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs)\n    })\n  }\n  // å¦‚æœè·¯ç”±æœ‰åˆ«åçš„è¯\n  // ç»™åˆ«åä¹Ÿæ·»åŠ è·¯ç”±è®°å½•\n  if (route.alias !== undefined) {\n    const aliases = Array.isArray(route.alias)\n      ? route.alias\n      : [route.alias]\n\n    aliases.forEach(alias => {\n      const aliasRoute = {\n        path: alias,\n        children: route.children\n      }\n      addRouteRecord(\n        pathList,\n        pathMap,\n        nameMap,\n        aliasRoute,\n        parent,\n        record.path || '/' // matchAs\n      )\n    })\n  }\n  // æ›´æ–°æ˜ å°„è¡¨\n  if (!pathMap[record.path]) {\n    pathList.push(record.path)\n    pathMap[record.path] = record\n  }\n  // å‘½åè·¯ç”±æ·»åŠ è®°å½•\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record\n    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {\n      warn(\n        false,\n        `Duplicate named routes definition: ` +\n        `{ name: \"${name}\", path: \"${record.path}\" }`\n      )\n    }\n  }\n}\n")])])]),r("p",[n._v("ä»¥ä¸Šå°±æ˜¯åˆ›å»ºè·¯ç”±åŒ¹é…å¯¹è±¡çš„å…¨è¿‡ç¨‹ï¼Œé€šè¿‡ç”¨æˆ·é…ç½®çš„è·¯ç”±è§„åˆ™æ¥åˆ›å»ºå¯¹åº”çš„è·¯ç”±æ˜ å°„è¡¨ã€‚")]),r("h2",{attrs:{id:"è·¯ç”±åˆå§‹åŒ–"}},[n._v("è·¯ç”±åˆå§‹åŒ–")]),r("p",[n._v("å½“æ ¹ç»„ä»¶è°ƒç”¨ "),r("code",[n._v("beforeCreate")]),n._v(" é’©å­å‡½æ•°æ—¶ï¼Œä¼šæ‰§è¡Œä»¥ä¸‹ä»£ç ")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("beforeCreate () {\n// åªæœ‰æ ¹ç»„ä»¶æœ‰ router å±æ€§ï¼Œæ‰€ä»¥æ ¹ç»„ä»¶åˆå§‹åŒ–æ—¶ä¼šåˆå§‹åŒ–è·¯ç”±\n  if (isDef(this.$options.router)) {\n    this._routerRoot = this\n    this._router = this.$options.router\n    this._router.init(this)\n    Vue.util.defineReactive(this, '_route', this._router.history.current)\n  } else {\n    this._routerRoot = (this.$parent && this.$parent._routerRoot) || this\n  }\n  registerInstance(this, this)\n}\n")])])]),r("p",[n._v("æ¥ä¸‹æ¥çœ‹ä¸‹è·¯ç”±åˆå§‹åŒ–ä¼šåšäº›ä»€ä¹ˆ")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("init(app: any /* Vue component instance */) {\n    // ä¿å­˜ç»„ä»¶å®ä¾‹\n    this.apps.push(app)\n    // å¦‚æœæ ¹ç»„ä»¶å·²ç»æœ‰äº†å°±è¿”å›\n    if (this.app) {\n      return\n    }\n    this.app = app\n    // èµ‹å€¼è·¯ç”±æ¨¡å¼\n    const history = this.history\n    // åˆ¤æ–­è·¯ç”±æ¨¡å¼ï¼Œä»¥å“ˆå¸Œæ¨¡å¼ä¸ºä¾‹\n    if (history instanceof HTML5History) {\n      history.transitionTo(history.getCurrentLocation())\n    } else if (history instanceof HashHistory) {\n      // æ·»åŠ  hashchange ç›‘å¬\n      const setupHashListener = () => {\n        history.setupListeners()\n      }\n      // è·¯ç”±è·³è½¬\n      history.transitionTo(\n        history.getCurrentLocation(),\n        setupHashListener,\n        setupHashListener\n      )\n    }\n    // è¯¥å›è°ƒä¼šåœ¨ transitionTo ä¸­è°ƒç”¨\n    // å¯¹ç»„ä»¶çš„ _route å±æ€§è¿›è¡Œèµ‹å€¼ï¼Œè§¦å‘ç»„ä»¶æ¸²æŸ“\n    history.listen(route => {\n      this.apps.forEach(app => {\n        app._route = route\n      })\n    })\n  }\n")])])]),r("p",[n._v("åœ¨è·¯ç”±åˆå§‹åŒ–æ—¶ï¼Œæ ¸å¿ƒå°±æ˜¯è¿›è¡Œè·¯ç”±çš„è·³è½¬ï¼Œæ”¹å˜ URL ç„¶åæ¸²æŸ“å¯¹åº”çš„ç»„ä»¶ã€‚æ¥ä¸‹æ¥æ¥çœ‹ä¸€ä¸‹è·¯ç”±æ˜¯å¦‚ä½•è¿›è¡Œè·³è½¬çš„ã€‚")]),r("h2",{attrs:{id:"è·¯ç”±è·³è½¬"}},[n._v("è·¯ç”±è·³è½¬")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  // è·å–åŒ¹é…çš„è·¯ç”±ä¿¡æ¯\n  const route = this.router.match(location, this.current)\n  // ç¡®è®¤åˆ‡æ¢è·¯ç”±\n  this.confirmTransition(route, () => {\n    // ä»¥ä¸‹ä¸ºåˆ‡æ¢è·¯ç”±æˆåŠŸæˆ–å¤±è´¥çš„å›è°ƒ\n    // æ›´æ–°è·¯ç”±ä¿¡æ¯ï¼Œå¯¹ç»„ä»¶çš„ _route å±æ€§è¿›è¡Œèµ‹å€¼ï¼Œè§¦å‘ç»„ä»¶æ¸²æŸ“\n    // è°ƒç”¨ afterHooks ä¸­çš„é’©å­å‡½æ•°\n    this.updateRoute(route)\n    // æ·»åŠ  hashchange ç›‘å¬\n    onComplete && onComplete(route)\n    // æ›´æ–° URL\n    this.ensureURL()\n    // åªæ‰§è¡Œä¸€æ¬¡ ready å›è°ƒ\n    if (!this.ready) {\n      this.ready = true\n      this.readyCbs.forEach(cb => { cb(route) })\n    }\n  }, err => {\n  // é”™è¯¯å¤„ç†\n    if (onAbort) {\n      onAbort(err)\n    }\n    if (err && !this.ready) {\n      this.ready = true\n      this.readyErrorCbs.forEach(cb => { cb(err) })\n    }\n  })\n}\n")])])]),r("p",[n._v("åœ¨è·¯ç”±è·³è½¬ä¸­ï¼Œéœ€è¦å…ˆè·å–åŒ¹é…çš„è·¯ç”±ä¿¡æ¯ï¼Œæ‰€ä»¥å…ˆæ¥çœ‹ä¸‹å¦‚ä½•è·å–åŒ¹é…çš„è·¯ç”±ä¿¡æ¯")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("function match (\n  raw: RawLocation,\n  currentRoute?: Route,\n  redirectedFrom?: Location\n): Route {\n  // åºåˆ—åŒ– url\n  // æ¯”å¦‚å¯¹äºè¯¥ url æ¥è¯´ /abc?foo=bar&baz=qux#hello\n  // ä¼šåºåˆ—åŒ–è·¯å¾„ä¸º /abc\n  // å“ˆå¸Œä¸º #hello\n  // å‚æ•°ä¸º foo: 'bar', baz: 'qux'\n  const location = normalizeLocation(raw, currentRoute, false, router)\n  const { name } = location\n  // å¦‚æœæ˜¯å‘½åè·¯ç”±ï¼Œå°±åˆ¤æ–­è®°å½•ä¸­æ˜¯å¦æœ‰è¯¥å‘½åè·¯ç”±é…ç½®\n  if (name) {\n    const record = nameMap[name]\n    // æ²¡æ‰¾åˆ°è¡¨ç¤ºæ²¡æœ‰åŒ¹é…çš„è·¯ç”±\n    if (!record) return _createRoute(null, location)\n    const paramNames = record.regex.keys\n      .filter(key => !key.optional)\n      .map(key => key.name)\n    // å‚æ•°å¤„ç†\n    if (typeof location.params !== 'object') {\n      location.params = {}\n    }\n    if (currentRoute && typeof currentRoute.params === 'object') {\n      for (const key in currentRoute.params) {\n        if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n          location.params[key] = currentRoute.params[key]\n        }\n      }\n    }\n    if (record) {\n      location.path = fillParams(record.path, location.params, `named route \"${name}\"`)\n      return _createRoute(record, location, redirectedFrom)\n    }\n  } else if (location.path) {\n    // éå‘½åè·¯ç”±å¤„ç†\n    location.params = {}\n    for (let i = 0; i < pathList.length; i++) {\n     // æŸ¥æ‰¾è®°å½•\n      const path = pathList[i]\n      const record = pathMap[path]\n      // å¦‚æœåŒ¹é…è·¯ç”±ï¼Œåˆ™åˆ›å»ºè·¯ç”±\n      if (matchRoute(record.regex, location.path, location.params)) {\n        return _createRoute(record, location, redirectedFrom)\n      }\n    }\n  }\n  // æ²¡æœ‰åŒ¹é…çš„è·¯ç”±\n  return _createRoute(null, location)\n}\n")])])]),r("p",[n._v("æ¥ä¸‹æ¥çœ‹çœ‹å¦‚ä½•åˆ›å»ºè·¯ç”±")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("// æ ¹æ®æ¡ä»¶åˆ›å»ºä¸åŒçš„è·¯ç”±\nfunction _createRoute(\n  record: ?RouteRecord,\n  location: Location,\n  redirectedFrom?: Location\n): Route {\n  if (record && record.redirect) {\n    return redirect(record, redirectedFrom || location)\n  }\n  if (record && record.matchAs) {\n    return alias(record, location, record.matchAs)\n  }\n  return createRoute(record, location, redirectedFrom, router)\n}\n\nexport function createRoute (\n  record: ?RouteRecord,\n  location: Location,\n  redirectedFrom?: ?Location,\n  router?: VueRouter\n): Route {\n  const stringifyQuery = router && router.options.stringifyQuery\n  // å…‹éš†å‚æ•°\n  let query: any = location.query || {}\n  try {\n    query = clone(query)\n  } catch (e) {}\n  // åˆ›å»ºè·¯ç”±å¯¹è±¡\n  const route: Route = {\n    name: location.name || (record && record.name),\n    meta: (record && record.meta) || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query,\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery),\n    matched: record ? formatMatch(record) : []\n  }\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery)\n  }\n  // è®©è·¯ç”±å¯¹è±¡ä¸å¯ä¿®æ”¹\n  return Object.freeze(route)\n}\n// è·å¾—åŒ…å«å½“å‰è·¯ç”±çš„æ‰€æœ‰åµŒå¥—è·¯å¾„ç‰‡æ®µçš„è·¯ç”±è®°å½•\n// åŒ…å«ä»æ ¹è·¯ç”±åˆ°å½“å‰è·¯ç”±çš„åŒ¹é…è®°å½•ï¼Œä»ä¸Šè‡³ä¸‹\nfunction formatMatch(record: ?RouteRecord): Array<RouteRecord> {\n  const res = []\n  while (record) {\n    res.unshift(record)\n    record = record.parent\n  }\n  return res\n}\n")])])]),r("p",[n._v("è‡³æ­¤åŒ¹é…è·¯ç”±å·²ç»å®Œæˆï¼Œæˆ‘ä»¬å›åˆ° "),r("code",[n._v("transitionTo")]),n._v(" å‡½æ•°ä¸­ï¼Œæ¥ä¸‹æ¥æ‰§è¡Œ "),r("code",[n._v("confirmTransition")])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  // ç¡®è®¤åˆ‡æ¢è·¯ç”±\n  this.confirmTransition(route, () => {}\n}\nconfirmTransition(route: Route, onComplete: Function, onAbort?: Function) {\n  const current = this.current\n  // ä¸­æ–­è·³è½¬è·¯ç”±å‡½æ•°\n  const abort = err => {\n    if (isError(err)) {\n      if (this.errorCbs.length) {\n        this.errorCbs.forEach(cb => {\n          cb(err)\n        })\n      } else {\n        warn(false, 'uncaught error during route navigation:')\n        console.error(err)\n      }\n    }\n    onAbort && onAbort(err)\n  }\n  // å¦‚æœæ˜¯ç›¸åŒçš„è·¯ç”±å°±ä¸è·³è½¬\n  if (\n    isSameRoute(route, current) &&\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL()\n    return abort()\n  }\n  // é€šè¿‡å¯¹æ¯”è·¯ç”±è§£æå‡ºå¯å¤ç”¨çš„ç»„ä»¶ï¼Œéœ€è¦æ¸²æŸ“çš„ç»„ä»¶ï¼Œå¤±æ´»çš„ç»„ä»¶\n  const { updated, deactivated, activated } = resolveQueue(\n    this.current.matched,\n    route.matched\n  )\n  \n  function resolveQueue(\n      current: Array<RouteRecord>,\n      next: Array<RouteRecord>\n    ): {\n      updated: Array<RouteRecord>,\n      activated: Array<RouteRecord>,\n      deactivated: Array<RouteRecord>\n    } {\n      let i\n      const max = Math.max(current.length, next.length)\n      for (i = 0; i < max; i++) {\n        // å½“å‰è·¯ç”±è·¯å¾„å’Œè·³è½¬è·¯ç”±è·¯å¾„ä¸åŒæ—¶è·³å‡ºéå†\n        if (current[i] !== next[i]) {\n          break\n        }\n      }\n      return {\n        // å¯å¤ç”¨çš„ç»„ä»¶å¯¹åº”è·¯ç”±\n        updated: next.slice(0, i),\n        // éœ€è¦æ¸²æŸ“çš„ç»„ä»¶å¯¹åº”è·¯ç”±\n        activated: next.slice(i),\n        // å¤±æ´»çš„ç»„ä»¶å¯¹åº”è·¯ç”±\n        deactivated: current.slice(i)\n      }\n  }\n  // å¯¼èˆªå®ˆå«æ•°ç»„\n  const queue: Array<?NavigationGuard> = [].concat(\n    // å¤±æ´»çš„ç»„ä»¶é’©å­\n    extractLeaveGuards(deactivated),\n    // å…¨å±€ beforeEach é’©å­\n    this.router.beforeHooks,\n    // åœ¨å½“å‰è·¯ç”±æ”¹å˜ï¼Œä½†æ˜¯è¯¥ç»„ä»¶è¢«å¤ç”¨æ—¶è°ƒç”¨\n    extractUpdateHooks(updated),\n    // éœ€è¦æ¸²æŸ“ç»„ä»¶ enter å®ˆå«é’©å­\n    activated.map(m => m.beforeEnter),\n    // è§£æå¼‚æ­¥è·¯ç”±ç»„ä»¶\n    resolveAsyncComponents(activated)\n  )\n  // ä¿å­˜è·¯ç”±\n  this.pending = route\n  // è¿­ä»£å™¨ï¼Œç”¨äºæ‰§è¡Œ queue ä¸­çš„å¯¼èˆªå®ˆå«é’©å­\n  const iterator = (hook: NavigationGuard, next) => {\n  // è·¯ç”±ä¸ç›¸ç­‰å°±ä¸è·³è½¬è·¯ç”±\n    if (this.pending !== route) {\n      return abort()\n    }\n    try {\n    // æ‰§è¡Œé’©å­\n      hook(route, current, (to: any) => {\n        // åªæœ‰æ‰§è¡Œäº†é’©å­å‡½æ•°ä¸­çš„ nextï¼Œæ‰ä¼šç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªé’©å­å‡½æ•°\n        // å¦åˆ™ä¼šæš‚åœè·³è½¬\n        // ä»¥ä¸‹é€»è¾‘æ˜¯åœ¨åˆ¤æ–­ next() ä¸­çš„ä¼ å‚\n        if (to === false || isError(to)) {\n          // next(false) \n          this.ensureURL(true)\n          abort(to)\n        } else if (\n          typeof to === 'string' ||\n          (typeof to === 'object' &&\n            (typeof to.path === 'string' || typeof to.name === 'string'))\n        ) {\n        // next('/') æˆ–è€… next({ path: '/' }) -> é‡å®šå‘\n          abort()\n          if (typeof to === 'object' && to.replace) {\n            this.replace(to)\n          } else {\n            this.push(to)\n          }\n        } else {\n        // è¿™é‡Œæ‰§è¡Œ next\n        // ä¹Ÿå°±æ˜¯æ‰§è¡Œä¸‹é¢å‡½æ•° runQueue ä¸­çš„ step(index + 1)\n          next(to)\n        }\n      })\n    } catch (e) {\n      abort(e)\n    }\n  }\n  // ç»å…¸çš„åŒæ­¥æ‰§è¡Œå¼‚æ­¥å‡½æ•°\n  runQueue(queue, iterator, () => {\n    const postEnterCbs = []\n    const isValid = () => this.current === route\n    // å½“æ‰€æœ‰å¼‚æ­¥ç»„ä»¶åŠ è½½å®Œæˆåï¼Œä¼šæ‰§è¡Œè¿™é‡Œçš„å›è°ƒï¼Œä¹Ÿå°±æ˜¯ runQueue ä¸­çš„ cb()\n    // æ¥ä¸‹æ¥æ‰§è¡Œ éœ€è¦æ¸²æŸ“ç»„ä»¶çš„å¯¼èˆªå®ˆå«é’©å­\n    const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)\n    const queue = enterGuards.concat(this.router.resolveHooks)\n    runQueue(queue, iterator, () => {\n    // è·³è½¬å®Œæˆ\n      if (this.pending !== route) {\n        return abort()\n      }\n      this.pending = null\n      onComplete(route)\n      if (this.router.app) {\n        this.router.app.$nextTick(() => {\n          postEnterCbs.forEach(cb => {\n            cb()\n          })\n        })\n      }\n    })\n  })\n}\nexport function runQueue (queue: Array<?NavigationGuard>, fn: Function, cb: Function) {\n  const step = index => {\n  // é˜Ÿåˆ—ä¸­çš„å‡½æ•°éƒ½æ‰§è¡Œå®Œæ¯•ï¼Œå°±æ‰§è¡Œå›è°ƒå‡½æ•°\n    if (index >= queue.length) {\n      cb()\n    } else {\n      if (queue[index]) {\n      // æ‰§è¡Œè¿­ä»£å™¨ï¼Œç”¨æˆ·åœ¨é’©å­å‡½æ•°ä¸­æ‰§è¡Œ next() å›è°ƒ\n      // å›è°ƒä¸­åˆ¤æ–­ä¼ å‚ï¼Œæ²¡æœ‰é—®é¢˜å°±æ‰§è¡Œ next()ï¼Œä¹Ÿå°±æ˜¯ fn å‡½æ•°ä¸­çš„ç¬¬äºŒä¸ªå‚æ•°\n        fn(queue[index], () => {\n          step(index + 1)\n        })\n      } else {\n        step(index + 1)\n      }\n    }\n  }\n  // å–å‡ºé˜Ÿåˆ—ä¸­ç¬¬ä¸€ä¸ªé’©å­å‡½æ•°\n  step(0)\n}\n")])])]),r("p",[n._v("æ¥ä¸‹æ¥ä»‹ç»å¯¼èˆªå®ˆå«")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const queue: Array<?NavigationGuard> = [].concat(\n    // å¤±æ´»çš„ç»„ä»¶é’©å­\n    extractLeaveGuards(deactivated),\n    // å…¨å±€ beforeEach é’©å­\n    this.router.beforeHooks,\n    // åœ¨å½“å‰è·¯ç”±æ”¹å˜ï¼Œä½†æ˜¯è¯¥ç»„ä»¶è¢«å¤ç”¨æ—¶è°ƒç”¨\n    extractUpdateHooks(updated),\n    // éœ€è¦æ¸²æŸ“ç»„ä»¶ enter å®ˆå«é’©å­\n    activated.map(m => m.beforeEnter),\n    // è§£æå¼‚æ­¥è·¯ç”±ç»„ä»¶\n    resolveAsyncComponents(activated)\n)\n")])])]),r("p",[n._v("ç¬¬ä¸€æ­¥æ˜¯å…ˆæ‰§è¡Œå¤±æ´»ç»„ä»¶çš„é’©å­å‡½æ•°")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("function extractLeaveGuards(deactivated: Array<RouteRecord>): Array<?Function> {\n// ä¼ å…¥éœ€è¦æ‰§è¡Œçš„é’©å­å‡½æ•°å\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\nfunction extractGuards(\n  records: Array<RouteRecord>,\n  name: string,\n  bind: Function,\n  reverse?: boolean\n): Array<?Function> {\n  const guards = flatMapComponents(records, (def, instance, match, key) => {\n   // æ‰¾å‡ºç»„ä»¶ä¸­å¯¹åº”çš„é’©å­å‡½æ•°\n    const guard = extractGuard(def, name)\n    if (guard) {\n    // ç»™æ¯ä¸ªé’©å­å‡½æ•°æ·»åŠ ä¸Šä¸‹æ–‡å¯¹è±¡ä¸ºç»„ä»¶è‡ªèº«\n      return Array.isArray(guard)\n        ? guard.map(guard => bind(guard, instance, match, key))\n        : bind(guard, instance, match, key)\n    }\n  })\n  // æ•°ç»„é™ç»´ï¼Œå¹¶ä¸”åˆ¤æ–­æ˜¯å¦éœ€è¦ç¿»è½¬æ•°ç»„\n  // å› ä¸ºæŸäº›é’©å­å‡½æ•°éœ€è¦ä»å­æ‰§è¡Œåˆ°çˆ¶\n  return flatten(reverse ? guards.reverse() : guards)\n}\nexport function flatMapComponents (\n  matched: Array<RouteRecord>,\n  fn: Function\n): Array<?Function> {\n// æ•°ç»„é™ç»´\n  return flatten(matched.map(m => {\n  // å°†ç»„ä»¶ä¸­çš„å¯¹è±¡ä¼ å…¥å›è°ƒå‡½æ•°ä¸­ï¼Œè·å¾—é’©å­å‡½æ•°æ•°ç»„\n    return Object.keys(m.components).map(key => fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ))\n  }))\n}\n")])])]),r("p",[n._v("ç¬¬äºŒæ­¥æ‰§è¡Œå…¨å±€ beforeEach é’©å­å‡½æ•°")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("beforeEach(fn: Function): Function {\n    return registerHook(this.beforeHooks, fn)\n}\nfunction registerHook(list: Array<any>, fn: Function): Function {\n  list.push(fn)\n  return () => {\n    const i = list.indexOf(fn)\n    if (i > -1) list.splice(i, 1)\n  }\n}\n")])])]),r("p",[n._v("åœ¨ VueRouter ç±»ä¸­æœ‰ä»¥ä¸Šä»£ç ï¼Œæ¯å½“ç»™ VueRouter å®ä¾‹æ·»åŠ  beforeEach å‡½æ•°æ—¶å°±ä¼šå°†å‡½æ•° push è¿› beforeHooks ä¸­ã€‚")]),r("p",[n._v("ç¬¬ä¸‰æ­¥æ‰§è¡Œ "),r("code",[n._v("beforeRouteUpdate")]),n._v(" é’©å­å‡½æ•°ï¼Œè°ƒç”¨æ–¹å¼å’Œç¬¬ä¸€æ­¥ç›¸åŒï¼Œåªæ˜¯ä¼ å…¥çš„å‡½æ•°åä¸åŒï¼Œåœ¨è¯¥å‡½æ•°ä¸­å¯ä»¥è®¿é—®åˆ° "),r("code",[n._v("this")]),n._v(" å¯¹è±¡ã€‚")]),r("p",[n._v("ç¬¬å››æ­¥æ‰§è¡Œ "),r("code",[n._v("beforeEnter")]),n._v(" é’©å­å‡½æ•°ï¼Œè¯¥å‡½æ•°æ˜¯è·¯ç”±ç‹¬äº«çš„é’©å­å‡½æ•°ã€‚")]),r("p",[n._v("ç¬¬äº”æ­¥æ˜¯è§£æå¼‚æ­¥ç»„ä»¶ã€‚")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("export function resolveAsyncComponents (matched: Array<RouteRecord>): Function {\n  return (to, from, next) => {\n    let hasAsync = false\n    let pending = 0\n    let error = null\n    // è¯¥å‡½æ•°ä½œç”¨ä¹‹å‰å·²ç»ä»‹ç»è¿‡äº†\n    flatMapComponents(matched, (def, _, match, key) => {\n    // åˆ¤æ–­æ˜¯å¦æ˜¯å¼‚æ­¥ç»„ä»¶\n      if (typeof def === 'function' && def.cid === undefined) {\n        hasAsync = true\n        pending++\n        // æˆåŠŸå›è°ƒ\n        // once å‡½æ•°ç¡®ä¿å¼‚æ­¥ç»„ä»¶åªåŠ è½½ä¸€æ¬¡\n        const resolve = once(resolvedDef => {\n          if (isESModule(resolvedDef)) {\n            resolvedDef = resolvedDef.default\n          }\n          // åˆ¤æ–­æ˜¯å¦æ˜¯æ„é€ å‡½æ•°\n          // ä¸æ˜¯çš„è¯é€šè¿‡ Vue æ¥ç”Ÿæˆç»„ä»¶æ„é€ å‡½æ•°\n          def.resolved = typeof resolvedDef === 'function'\n            ? resolvedDef\n            : _Vue.extend(resolvedDef)\n        // èµ‹å€¼ç»„ä»¶\n        // å¦‚æœç»„ä»¶å…¨éƒ¨è§£æå®Œæ¯•ï¼Œç»§ç»­ä¸‹ä¸€æ­¥\n          match.components[key] = resolvedDef\n          pending--\n          if (pending <= 0) {\n            next()\n          }\n        })\n        // å¤±è´¥å›è°ƒ\n        const reject = once(reason => {\n          const msg = `Failed to resolve async component ${key}: ${reason}`\n          process.env.NODE_ENV !== 'production' && warn(false, msg)\n          if (!error) {\n            error = isError(reason)\n              ? reason\n              : new Error(msg)\n            next(error)\n          }\n        })\n        let res\n        try {\n        // æ‰§è¡Œå¼‚æ­¥ç»„ä»¶å‡½æ•°\n          res = def(resolve, reject)\n        } catch (e) {\n          reject(e)\n        }\n        if (res) {\n        // ä¸‹è½½å®Œæˆæ‰§è¡Œå›è°ƒ\n          if (typeof res.then === 'function') {\n            res.then(resolve, reject)\n          } else {\n            const comp = res.component\n            if (comp && typeof comp.then === 'function') {\n              comp.then(resolve, reject)\n            }\n          }\n        }\n      }\n    })\n    // ä¸æ˜¯å¼‚æ­¥ç»„ä»¶ç›´æ¥ä¸‹ä¸€æ­¥\n    if (!hasAsync) next()\n  }\n}\n")])])]),r("p",[n._v("ä»¥ä¸Šå°±æ˜¯ç¬¬ä¸€ä¸ª "),r("code",[n._v("runQueue")]),n._v(" ä¸­çš„é€»è¾‘ï¼Œç¬¬äº”æ­¥å®Œæˆåä¼šæ‰§è¡Œç¬¬ä¸€ä¸ª "),r("code",[n._v("runQueue")]),n._v(" ä¸­å›è°ƒå‡½æ•°")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("// è¯¥å›è°ƒç”¨äºä¿å­˜ `beforeRouteEnter` é’©å­ä¸­çš„å›è°ƒå‡½æ•°\nconst postEnterCbs = []\nconst isValid = () => this.current === route\n// beforeRouteEnter å¯¼èˆªå®ˆå«é’©å­\nconst enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)\n// beforeResolve å¯¼èˆªå®ˆå«é’©å­\nconst queue = enterGuards.concat(this.router.resolveHooks)\nrunQueue(queue, iterator, () => {\n  if (this.pending !== route) {\n    return abort()\n  }\n  this.pending = null\n  // è¿™é‡Œä¼šæ‰§è¡Œ afterEach å¯¼èˆªå®ˆå«é’©å­\n  onComplete(route)\n  if (this.router.app) {\n    this.router.app.$nextTick(() => {\n      postEnterCbs.forEach(cb => {\n        cb()\n      })\n    })\n  }\n})\n")])])]),r("p",[n._v("ç¬¬å…­æ­¥æ˜¯æ‰§è¡Œ "),r("code",[n._v("beforeRouteEnter")]),n._v(" å¯¼èˆªå®ˆå«é’©å­ï¼Œ"),r("code",[n._v("beforeRouteEnter")]),n._v(" é’©å­ä¸èƒ½è®¿é—® "),r("code",[n._v("this")]),n._v(" å¯¹è±¡ï¼Œå› ä¸ºé’©å­åœ¨å¯¼èˆªç¡®è®¤å‰è¢«è°ƒç”¨ï¼Œéœ€è¦æ¸²æŸ“çš„ç»„ä»¶è¿˜æ²¡è¢«åˆ›å»ºã€‚ä½†æ˜¯è¯¥é’©å­å‡½æ•°æ˜¯å”¯ä¸€ä¸€ä¸ªæ”¯æŒåœ¨å›è°ƒä¸­è·å– "),r("code",[n._v("this")]),n._v(" å¯¹è±¡çš„å‡½æ•°ï¼Œå›è°ƒä¼šåœ¨è·¯ç”±ç¡®è®¤æ‰§è¡Œã€‚")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("beforeRouteEnter (to, from, next) {\n  next(vm => {\n    // é€šè¿‡ `vm` è®¿é—®ç»„ä»¶å®ä¾‹\n  })\n}\n")])])]),r("p",[n._v("ä¸‹é¢æ¥çœ‹çœ‹æ˜¯å¦‚ä½•æ”¯æŒåœ¨å›è°ƒä¸­æ‹¿åˆ° "),r("code",[n._v("this")]),n._v(" å¯¹è±¡çš„")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("function extractEnterGuards(\n  activated: Array<RouteRecord>,\n  cbs: Array<Function>,\n  isValid: () => boolean\n): Array<?Function> {\n// è¿™é‡Œå’Œä¹‹å‰è°ƒç”¨å¯¼èˆªå®ˆå«åŸºæœ¬ä¸€è‡´\n  return extractGuards(\n    activated,\n    'beforeRouteEnter',\n    (guard, _, match, key) => {\n      return bindEnterGuard(guard, match, key, cbs, isValid)\n    }\n  )\n}\nfunction bindEnterGuard(\n  guard: NavigationGuard,\n  match: RouteRecord,\n  key: string,\n  cbs: Array<Function>,\n  isValid: () => boolean\n): NavigationGuard {\n  return function routeEnterGuard(to, from, next) {\n    return guard(to, from, cb => {\n    // åˆ¤æ–­ cb æ˜¯å¦æ˜¯å‡½æ•°\n    // æ˜¯çš„è¯å°± push è¿› postEnterCbs\n      next(cb)\n      if (typeof cb === 'function') {\n        cbs.push(() => {\n          // å¾ªç¯ç›´åˆ°æ‹¿åˆ°ç»„ä»¶å®ä¾‹\n          poll(cb, match.instances, key, isValid)\n        })\n      }\n    })\n  }\n}\n// è¯¥å‡½æ•°æ˜¯ä¸ºäº†è§£å†³ issus #750\n// å½“ router-view å¤–é¢åŒ…è£¹äº† mode ä¸º out-in çš„ transition ç»„ä»¶ \n// ä¼šåœ¨ç»„ä»¶åˆæ¬¡å¯¼èˆªåˆ°æ—¶è·å¾—ä¸åˆ°ç»„ä»¶å®ä¾‹å¯¹è±¡\nfunction poll(\n  cb: any, // somehow flow cannot infer this is a function\n  instances: Object,\n  key: string,\n  isValid: () => boolean\n) {\n  if (\n    instances[key] &&\n    !instances[key]._isBeingDestroyed // do not reuse being destroyed instance\n  ) {\n    cb(instances[key])\n  } else if (isValid()) {\n  // setTimeout 16ms ä½œç”¨å’Œ nextTick åŸºæœ¬ç›¸åŒ\n    setTimeout(() => {\n      poll(cb, instances, key, isValid)\n    }, 16)\n  }\n}\n")])])]),r("p",[n._v("ç¬¬ä¸ƒæ­¥æ˜¯æ‰§è¡Œ "),r("code",[n._v("beforeResolve")]),n._v(" å¯¼èˆªå®ˆå«é’©å­ï¼Œå¦‚æœæ³¨å†Œäº†å…¨å±€ "),r("code",[n._v("beforeResolve")]),n._v(" é’©å­å°±ä¼šåœ¨è¿™é‡Œæ‰§è¡Œã€‚")]),r("p",[n._v("ç¬¬å…«æ­¥å°±æ˜¯å¯¼èˆªç¡®è®¤ï¼Œè°ƒç”¨ "),r("code",[n._v("afterEach")]),n._v(" å¯¼èˆªå®ˆå«é’©å­äº†ã€‚")]),r("p",[n._v("ä»¥ä¸Šéƒ½æ‰§è¡Œå®Œæˆåï¼Œä¼šè§¦å‘ç»„ä»¶çš„æ¸²æŸ“")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("history.listen(route => {\n      this.apps.forEach(app => {\n        app._route = route\n      })\n})\n")])])]),r("p",[n._v("ä»¥ä¸Šå›è°ƒä¼šåœ¨ "),r("code",[n._v("updateRoute")]),n._v(" ä¸­è°ƒç”¨")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("updateRoute(route: Route) {\n    const prev = this.current\n    this.current = route\n    this.cb && this.cb(route)\n    this.router.afterHooks.forEach(hook => {\n      hook && hook(route, prev)\n    })\n}\n")])])]),r("p",[n._v("è‡³æ­¤ï¼Œè·¯ç”±è·³è½¬å·²ç»å…¨éƒ¨åˆ†æå®Œæ¯•ã€‚æ ¸å¿ƒå°±æ˜¯åˆ¤æ–­éœ€è¦è·³è½¬çš„è·¯ç”±æ˜¯å¦å­˜åœ¨äºè®°å½•ä¸­ï¼Œç„¶åæ‰§è¡Œå„ç§å¯¼èˆªå®ˆå«å‡½æ•°ï¼Œæœ€åå®Œæˆ URL çš„æ”¹å˜å’Œç»„ä»¶çš„æ¸²æŸ“ã€‚")]),r("p",[n._v("Now, let's try it ğŸ‘‰")])])}],o=t(0),a=Object(o.a)({},(function(){var n=this.$createElement;this._self._c;return this._m(0)}),r,!1,null,null,null);e.default=a.exports}}]);