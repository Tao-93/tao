(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{230:function(n,e,t){n.exports=t.p+"assets/img/vue_02.5b4ddc25.png"},283:function(n,e,t){"use strict";t.r(e);var r=[function(){var n=this,e=n.$createElement,r=n._self._c||e;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"vuerouter"}},[n._v("VueRouter")]),r("h3",{attrs:{id:"重要函数思维导图"}},[n._v("重要函数思维导图")]),r("p",[n._v("以下思维导图罗列了源码中重要的一些函数 "),r("img",{attrs:{src:t(230),alt:"img"}})]),r("h2",{attrs:{id:"路由注册"}},[n._v("路由注册")]),r("p",[n._v("在开始之前，推荐大家 clone 一份源码对照着看。因为篇幅较长，函数间的跳转也很多。")]),r("p",[n._v("使用路由之前，需要调用 "),r("code",[n._v("Vue.use(VueRouter)")]),n._v("，这是因为让插件可以使用 Vue")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("export function initUse (Vue: GlobalAPI) {\n  Vue.use = function (plugin: Function | Object) {\n    // 判断重复安装插件\n    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n    const args = toArray(arguments, 1)\n    // 插入 Vue\n    args.unshift(this)\n    // 一般插件都会有一个 install 函数\n    // 通过该函数让插件可以使用 Vue\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args)\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args)\n    }\n    installedPlugins.push(plugin)\n    return this\n  }\n}\n")])])]),r("p",[n._v("接下来看下 "),r("code",[n._v("install")]),n._v(" 函数的部分实现")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("export function install (Vue) {\n  // 确保 install 调用一次\n  if (install.installed && _Vue === Vue) return\n  install.installed = true\n  // 把 Vue 赋值给全局变量\n  _Vue = Vue\n  const registerInstance = (vm, callVal) => {\n    let i = vm.$options._parentVnode\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal)\n    }\n  }\n  // 给每个组件的钩子函数混入实现\n  // 可以发现在 `beforeCreate` 钩子执行时\n  // 会初始化路由\n  Vue.mixin({\n    beforeCreate () {\n      // 判断组件是否存在 router 对象，该对象只在根组件上有\n      if (isDef(this.$options.router)) {\n        // 根路由设置为自己\n        this._routerRoot = this\n        this._router = this.$options.router\n        // 初始化路由\n        this._router.init(this)\n        // 很重要，为 _route 属性实现双向绑定\n        // 触发组件渲染\n        Vue.util.defineReactive(this, '_route', this._router.history.current)\n      } else {\n        // 用于 router-view 层级判断\n        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this\n      }\n      registerInstance(this, this)\n    },\n    destroyed () {\n      registerInstance(this)\n    }\n  })\n  // 全局注册组件 router-link 和 router-view\n  Vue.component('RouterView', View)\n  Vue.component('RouterLink', Link)\n}\n")])])]),r("p",[n._v("对于路由注册来说，核心就是调用 "),r("code",[n._v("Vue.use(VueRouter)")]),n._v("，使得 VueRouter 可以使用 Vue。然后通过 Vue 来调用 VueRouter 的 "),r("code",[n._v("install")]),n._v(" 函数。在该函数中，核心就是给组件混入钩子函数和全局注册两个路由组件。")]),r("h2",{attrs:{id:"vuerouter实例化"}},[n._v("VueRouter实例化")]),r("p",[n._v("在安装插件后，对 VueRouter 进行实例化。")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const Home = { template: '<div>home</div>' }\nconst Foo = { template: '<div>foo</div>' }\nconst Bar = { template: '<div>bar</div>' }\n\n// 3. Create the router\nconst router = new VueRouter({\n  mode: 'hash',\n  base: __dirname,\n  routes: [\n    { path: '/', component: Home }, // all paths are defined without the hash.\n    { path: '/foo', component: Foo },\n    { path: '/bar', component: Bar }\n  ]\n})\n")])])]),r("p",[n._v("来看一下 VueRouter 的构造函数")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("constructor(options: RouterOptions = {}) {\n    // ...\n    // 路由匹配对象\n    this.matcher = createMatcher(options.routes || [], this)\n\n    // 根据 mode 采取不同的路由方式\n    let mode = options.mode || 'hash'\n    this.fallback =\n      mode === 'history' && !supportsPushState && options.fallback !== false\n    if (this.fallback) {\n      mode = 'hash'\n    }\n    if (!inBrowser) {\n      mode = 'abstract'\n    }\n    this.mode = mode\n\n    switch (mode) {\n      case 'history':\n        this.history = new HTML5History(this, options.base)\n        break\n      case 'hash':\n        this.history = new HashHistory(this, options.base, this.fallback)\n        break\n      case 'abstract':\n        this.history = new AbstractHistory(this, options.base)\n        break\n      default:\n        if (process.env.NODE_ENV !== 'production') {\n          assert(false, `invalid mode: ${mode}`)\n        }\n    }\n  }\n")])])]),r("p",[n._v("在实例化 VueRouter 的过程中，核心是创建一个路由匹配对象，并且根据 mode 来采取不同的路由方式。")]),r("h2",{attrs:{id:"创建路由匹配对象"}},[n._v("创建路由匹配对象")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("export function createMatcher (\n  routes: Array<RouteConfig>,\n  router: VueRouter\n): Matcher {\n    // 创建路由映射表\n  const { pathList, pathMap, nameMap } = createRouteMap(routes)\n    \n  function addRoutes (routes) {\n    createRouteMap(routes, pathList, pathMap, nameMap)\n  }\n  // 路由匹配\n  function match (\n    raw: RawLocation,\n    currentRoute?: Route,\n    redirectedFrom?: Location\n  ): Route {\n    //...\n  }\n\n  return {\n    match,\n    addRoutes\n  }\n}\n")])])]),r("p",[r("code",[n._v("createMatcher")]),n._v(" 函数的作用就是创建路由映射表，然后通过闭包的方式让 "),r("code",[n._v("addRoutes")]),n._v(" 和 "),r("code",[n._v("match")]),n._v(" 函数能够使用路由映射表的几个对象，最后返回一个 "),r("code",[n._v("Matcher")]),n._v(" 对象。")]),r("p",[n._v("接下来看 "),r("code",[n._v("createMatcher")]),n._v(" 函数时如何创建映射表的")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("export function createRouteMap (\n  routes: Array<RouteConfig>,\n  oldPathList?: Array<string>,\n  oldPathMap?: Dictionary<RouteRecord>,\n  oldNameMap?: Dictionary<RouteRecord>\n): {\n  pathList: Array<string>;\n  pathMap: Dictionary<RouteRecord>;\n  nameMap: Dictionary<RouteRecord>;\n} {\n  // 创建映射表\n  const pathList: Array<string> = oldPathList || []\n  const pathMap: Dictionary<RouteRecord> = oldPathMap || Object.create(null)\n  const nameMap: Dictionary<RouteRecord> = oldNameMap || Object.create(null)\n  // 遍历路由配置，为每个配置添加路由记录\n  routes.forEach(route => {\n    addRouteRecord(pathList, pathMap, nameMap, route)\n  })\n  // 确保通配符在最后\n  for (let i = 0, l = pathList.length; i < l; i++) {\n    if (pathList[i] === '*') {\n      pathList.push(pathList.splice(i, 1)[0])\n      l--\n      i--\n    }\n  }\n  return {\n    pathList,\n    pathMap,\n    nameMap\n  }\n}\n// 添加路由记录\nfunction addRouteRecord (\n  pathList: Array<string>,\n  pathMap: Dictionary<RouteRecord>,\n  nameMap: Dictionary<RouteRecord>,\n  route: RouteConfig,\n  parent?: RouteRecord,\n  matchAs?: string\n) {\n  // 获得路由配置下的属性\n  const { path, name } = route\n  const pathToRegexpOptions: PathToRegexpOptions = route.pathToRegexpOptions || {}\n  // 格式化 url，替换 / \n  const normalizedPath = normalizePath(\n    path,\n    parent,\n    pathToRegexpOptions.strict\n  )\n  // 生成记录对象\n  const record: RouteRecord = {\n    path: normalizedPath,\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n    components: route.components || { default: route.component },\n    instances: {},\n    name,\n    parent,\n    matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null\n      ? {}\n      : route.components\n        ? route.props\n        : { default: route.props }\n  }\n\n  if (route.children) {\n    // 递归路由配置的 children 属性，添加路由记录\n    route.children.forEach(child => {\n      const childMatchAs = matchAs\n        ? cleanPath(`${matchAs}/${child.path}`)\n        : undefined\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs)\n    })\n  }\n  // 如果路由有别名的话\n  // 给别名也添加路由记录\n  if (route.alias !== undefined) {\n    const aliases = Array.isArray(route.alias)\n      ? route.alias\n      : [route.alias]\n\n    aliases.forEach(alias => {\n      const aliasRoute = {\n        path: alias,\n        children: route.children\n      }\n      addRouteRecord(\n        pathList,\n        pathMap,\n        nameMap,\n        aliasRoute,\n        parent,\n        record.path || '/' // matchAs\n      )\n    })\n  }\n  // 更新映射表\n  if (!pathMap[record.path]) {\n    pathList.push(record.path)\n    pathMap[record.path] = record\n  }\n  // 命名路由添加记录\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record\n    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {\n      warn(\n        false,\n        `Duplicate named routes definition: ` +\n        `{ name: \"${name}\", path: \"${record.path}\" }`\n      )\n    }\n  }\n}\n")])])]),r("p",[n._v("以上就是创建路由匹配对象的全过程，通过用户配置的路由规则来创建对应的路由映射表。")]),r("h2",{attrs:{id:"路由初始化"}},[n._v("路由初始化")]),r("p",[n._v("当根组件调用 "),r("code",[n._v("beforeCreate")]),n._v(" 钩子函数时，会执行以下代码")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("beforeCreate () {\n// 只有根组件有 router 属性，所以根组件初始化时会初始化路由\n  if (isDef(this.$options.router)) {\n    this._routerRoot = this\n    this._router = this.$options.router\n    this._router.init(this)\n    Vue.util.defineReactive(this, '_route', this._router.history.current)\n  } else {\n    this._routerRoot = (this.$parent && this.$parent._routerRoot) || this\n  }\n  registerInstance(this, this)\n}\n")])])]),r("p",[n._v("接下来看下路由初始化会做些什么")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("init(app: any /* Vue component instance */) {\n    // 保存组件实例\n    this.apps.push(app)\n    // 如果根组件已经有了就返回\n    if (this.app) {\n      return\n    }\n    this.app = app\n    // 赋值路由模式\n    const history = this.history\n    // 判断路由模式，以哈希模式为例\n    if (history instanceof HTML5History) {\n      history.transitionTo(history.getCurrentLocation())\n    } else if (history instanceof HashHistory) {\n      // 添加 hashchange 监听\n      const setupHashListener = () => {\n        history.setupListeners()\n      }\n      // 路由跳转\n      history.transitionTo(\n        history.getCurrentLocation(),\n        setupHashListener,\n        setupHashListener\n      )\n    }\n    // 该回调会在 transitionTo 中调用\n    // 对组件的 _route 属性进行赋值，触发组件渲染\n    history.listen(route => {\n      this.apps.forEach(app => {\n        app._route = route\n      })\n    })\n  }\n")])])]),r("p",[n._v("在路由初始化时，核心就是进行路由的跳转，改变 URL 然后渲染对应的组件。接下来来看一下路由是如何进行跳转的。")]),r("h2",{attrs:{id:"路由跳转"}},[n._v("路由跳转")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  // 获取匹配的路由信息\n  const route = this.router.match(location, this.current)\n  // 确认切换路由\n  this.confirmTransition(route, () => {\n    // 以下为切换路由成功或失败的回调\n    // 更新路由信息，对组件的 _route 属性进行赋值，触发组件渲染\n    // 调用 afterHooks 中的钩子函数\n    this.updateRoute(route)\n    // 添加 hashchange 监听\n    onComplete && onComplete(route)\n    // 更新 URL\n    this.ensureURL()\n    // 只执行一次 ready 回调\n    if (!this.ready) {\n      this.ready = true\n      this.readyCbs.forEach(cb => { cb(route) })\n    }\n  }, err => {\n  // 错误处理\n    if (onAbort) {\n      onAbort(err)\n    }\n    if (err && !this.ready) {\n      this.ready = true\n      this.readyErrorCbs.forEach(cb => { cb(err) })\n    }\n  })\n}\n")])])]),r("p",[n._v("在路由跳转中，需要先获取匹配的路由信息，所以先来看下如何获取匹配的路由信息")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("function match (\n  raw: RawLocation,\n  currentRoute?: Route,\n  redirectedFrom?: Location\n): Route {\n  // 序列化 url\n  // 比如对于该 url 来说 /abc?foo=bar&baz=qux#hello\n  // 会序列化路径为 /abc\n  // 哈希为 #hello\n  // 参数为 foo: 'bar', baz: 'qux'\n  const location = normalizeLocation(raw, currentRoute, false, router)\n  const { name } = location\n  // 如果是命名路由，就判断记录中是否有该命名路由配置\n  if (name) {\n    const record = nameMap[name]\n    // 没找到表示没有匹配的路由\n    if (!record) return _createRoute(null, location)\n    const paramNames = record.regex.keys\n      .filter(key => !key.optional)\n      .map(key => key.name)\n    // 参数处理\n    if (typeof location.params !== 'object') {\n      location.params = {}\n    }\n    if (currentRoute && typeof currentRoute.params === 'object') {\n      for (const key in currentRoute.params) {\n        if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n          location.params[key] = currentRoute.params[key]\n        }\n      }\n    }\n    if (record) {\n      location.path = fillParams(record.path, location.params, `named route \"${name}\"`)\n      return _createRoute(record, location, redirectedFrom)\n    }\n  } else if (location.path) {\n    // 非命名路由处理\n    location.params = {}\n    for (let i = 0; i < pathList.length; i++) {\n     // 查找记录\n      const path = pathList[i]\n      const record = pathMap[path]\n      // 如果匹配路由，则创建路由\n      if (matchRoute(record.regex, location.path, location.params)) {\n        return _createRoute(record, location, redirectedFrom)\n      }\n    }\n  }\n  // 没有匹配的路由\n  return _createRoute(null, location)\n}\n")])])]),r("p",[n._v("接下来看看如何创建路由")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("// 根据条件创建不同的路由\nfunction _createRoute(\n  record: ?RouteRecord,\n  location: Location,\n  redirectedFrom?: Location\n): Route {\n  if (record && record.redirect) {\n    return redirect(record, redirectedFrom || location)\n  }\n  if (record && record.matchAs) {\n    return alias(record, location, record.matchAs)\n  }\n  return createRoute(record, location, redirectedFrom, router)\n}\n\nexport function createRoute (\n  record: ?RouteRecord,\n  location: Location,\n  redirectedFrom?: ?Location,\n  router?: VueRouter\n): Route {\n  const stringifyQuery = router && router.options.stringifyQuery\n  // 克隆参数\n  let query: any = location.query || {}\n  try {\n    query = clone(query)\n  } catch (e) {}\n  // 创建路由对象\n  const route: Route = {\n    name: location.name || (record && record.name),\n    meta: (record && record.meta) || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query,\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery),\n    matched: record ? formatMatch(record) : []\n  }\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery)\n  }\n  // 让路由对象不可修改\n  return Object.freeze(route)\n}\n// 获得包含当前路由的所有嵌套路径片段的路由记录\n// 包含从根路由到当前路由的匹配记录，从上至下\nfunction formatMatch(record: ?RouteRecord): Array<RouteRecord> {\n  const res = []\n  while (record) {\n    res.unshift(record)\n    record = record.parent\n  }\n  return res\n}\n")])])]),r("p",[n._v("至此匹配路由已经完成，我们回到 "),r("code",[n._v("transitionTo")]),n._v(" 函数中，接下来执行 "),r("code",[n._v("confirmTransition")])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  // 确认切换路由\n  this.confirmTransition(route, () => {}\n}\nconfirmTransition(route: Route, onComplete: Function, onAbort?: Function) {\n  const current = this.current\n  // 中断跳转路由函数\n  const abort = err => {\n    if (isError(err)) {\n      if (this.errorCbs.length) {\n        this.errorCbs.forEach(cb => {\n          cb(err)\n        })\n      } else {\n        warn(false, 'uncaught error during route navigation:')\n        console.error(err)\n      }\n    }\n    onAbort && onAbort(err)\n  }\n  // 如果是相同的路由就不跳转\n  if (\n    isSameRoute(route, current) &&\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL()\n    return abort()\n  }\n  // 通过对比路由解析出可复用的组件，需要渲染的组件，失活的组件\n  const { updated, deactivated, activated } = resolveQueue(\n    this.current.matched,\n    route.matched\n  )\n  \n  function resolveQueue(\n      current: Array<RouteRecord>,\n      next: Array<RouteRecord>\n    ): {\n      updated: Array<RouteRecord>,\n      activated: Array<RouteRecord>,\n      deactivated: Array<RouteRecord>\n    } {\n      let i\n      const max = Math.max(current.length, next.length)\n      for (i = 0; i < max; i++) {\n        // 当前路由路径和跳转路由路径不同时跳出遍历\n        if (current[i] !== next[i]) {\n          break\n        }\n      }\n      return {\n        // 可复用的组件对应路由\n        updated: next.slice(0, i),\n        // 需要渲染的组件对应路由\n        activated: next.slice(i),\n        // 失活的组件对应路由\n        deactivated: current.slice(i)\n      }\n  }\n  // 导航守卫数组\n  const queue: Array<?NavigationGuard> = [].concat(\n    // 失活的组件钩子\n    extractLeaveGuards(deactivated),\n    // 全局 beforeEach 钩子\n    this.router.beforeHooks,\n    // 在当前路由改变，但是该组件被复用时调用\n    extractUpdateHooks(updated),\n    // 需要渲染组件 enter 守卫钩子\n    activated.map(m => m.beforeEnter),\n    // 解析异步路由组件\n    resolveAsyncComponents(activated)\n  )\n  // 保存路由\n  this.pending = route\n  // 迭代器，用于执行 queue 中的导航守卫钩子\n  const iterator = (hook: NavigationGuard, next) => {\n  // 路由不相等就不跳转路由\n    if (this.pending !== route) {\n      return abort()\n    }\n    try {\n    // 执行钩子\n      hook(route, current, (to: any) => {\n        // 只有执行了钩子函数中的 next，才会继续执行下一个钩子函数\n        // 否则会暂停跳转\n        // 以下逻辑是在判断 next() 中的传参\n        if (to === false || isError(to)) {\n          // next(false) \n          this.ensureURL(true)\n          abort(to)\n        } else if (\n          typeof to === 'string' ||\n          (typeof to === 'object' &&\n            (typeof to.path === 'string' || typeof to.name === 'string'))\n        ) {\n        // next('/') 或者 next({ path: '/' }) -> 重定向\n          abort()\n          if (typeof to === 'object' && to.replace) {\n            this.replace(to)\n          } else {\n            this.push(to)\n          }\n        } else {\n        // 这里执行 next\n        // 也就是执行下面函数 runQueue 中的 step(index + 1)\n          next(to)\n        }\n      })\n    } catch (e) {\n      abort(e)\n    }\n  }\n  // 经典的同步执行异步函数\n  runQueue(queue, iterator, () => {\n    const postEnterCbs = []\n    const isValid = () => this.current === route\n    // 当所有异步组件加载完成后，会执行这里的回调，也就是 runQueue 中的 cb()\n    // 接下来执行 需要渲染组件的导航守卫钩子\n    const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)\n    const queue = enterGuards.concat(this.router.resolveHooks)\n    runQueue(queue, iterator, () => {\n    // 跳转完成\n      if (this.pending !== route) {\n        return abort()\n      }\n      this.pending = null\n      onComplete(route)\n      if (this.router.app) {\n        this.router.app.$nextTick(() => {\n          postEnterCbs.forEach(cb => {\n            cb()\n          })\n        })\n      }\n    })\n  })\n}\nexport function runQueue (queue: Array<?NavigationGuard>, fn: Function, cb: Function) {\n  const step = index => {\n  // 队列中的函数都执行完毕，就执行回调函数\n    if (index >= queue.length) {\n      cb()\n    } else {\n      if (queue[index]) {\n      // 执行迭代器，用户在钩子函数中执行 next() 回调\n      // 回调中判断传参，没有问题就执行 next()，也就是 fn 函数中的第二个参数\n        fn(queue[index], () => {\n          step(index + 1)\n        })\n      } else {\n        step(index + 1)\n      }\n    }\n  }\n  // 取出队列中第一个钩子函数\n  step(0)\n}\n")])])]),r("p",[n._v("接下来介绍导航守卫")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const queue: Array<?NavigationGuard> = [].concat(\n    // 失活的组件钩子\n    extractLeaveGuards(deactivated),\n    // 全局 beforeEach 钩子\n    this.router.beforeHooks,\n    // 在当前路由改变，但是该组件被复用时调用\n    extractUpdateHooks(updated),\n    // 需要渲染组件 enter 守卫钩子\n    activated.map(m => m.beforeEnter),\n    // 解析异步路由组件\n    resolveAsyncComponents(activated)\n)\n")])])]),r("p",[n._v("第一步是先执行失活组件的钩子函数")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("function extractLeaveGuards(deactivated: Array<RouteRecord>): Array<?Function> {\n// 传入需要执行的钩子函数名\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\nfunction extractGuards(\n  records: Array<RouteRecord>,\n  name: string,\n  bind: Function,\n  reverse?: boolean\n): Array<?Function> {\n  const guards = flatMapComponents(records, (def, instance, match, key) => {\n   // 找出组件中对应的钩子函数\n    const guard = extractGuard(def, name)\n    if (guard) {\n    // 给每个钩子函数添加上下文对象为组件自身\n      return Array.isArray(guard)\n        ? guard.map(guard => bind(guard, instance, match, key))\n        : bind(guard, instance, match, key)\n    }\n  })\n  // 数组降维，并且判断是否需要翻转数组\n  // 因为某些钩子函数需要从子执行到父\n  return flatten(reverse ? guards.reverse() : guards)\n}\nexport function flatMapComponents (\n  matched: Array<RouteRecord>,\n  fn: Function\n): Array<?Function> {\n// 数组降维\n  return flatten(matched.map(m => {\n  // 将组件中的对象传入回调函数中，获得钩子函数数组\n    return Object.keys(m.components).map(key => fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ))\n  }))\n}\n")])])]),r("p",[n._v("第二步执行全局 beforeEach 钩子函数")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("beforeEach(fn: Function): Function {\n    return registerHook(this.beforeHooks, fn)\n}\nfunction registerHook(list: Array<any>, fn: Function): Function {\n  list.push(fn)\n  return () => {\n    const i = list.indexOf(fn)\n    if (i > -1) list.splice(i, 1)\n  }\n}\n")])])]),r("p",[n._v("在 VueRouter 类中有以上代码，每当给 VueRouter 实例添加 beforeEach 函数时就会将函数 push 进 beforeHooks 中。")]),r("p",[n._v("第三步执行 "),r("code",[n._v("beforeRouteUpdate")]),n._v(" 钩子函数，调用方式和第一步相同，只是传入的函数名不同，在该函数中可以访问到 "),r("code",[n._v("this")]),n._v(" 对象。")]),r("p",[n._v("第四步执行 "),r("code",[n._v("beforeEnter")]),n._v(" 钩子函数，该函数是路由独享的钩子函数。")]),r("p",[n._v("第五步是解析异步组件。")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("export function resolveAsyncComponents (matched: Array<RouteRecord>): Function {\n  return (to, from, next) => {\n    let hasAsync = false\n    let pending = 0\n    let error = null\n    // 该函数作用之前已经介绍过了\n    flatMapComponents(matched, (def, _, match, key) => {\n    // 判断是否是异步组件\n      if (typeof def === 'function' && def.cid === undefined) {\n        hasAsync = true\n        pending++\n        // 成功回调\n        // once 函数确保异步组件只加载一次\n        const resolve = once(resolvedDef => {\n          if (isESModule(resolvedDef)) {\n            resolvedDef = resolvedDef.default\n          }\n          // 判断是否是构造函数\n          // 不是的话通过 Vue 来生成组件构造函数\n          def.resolved = typeof resolvedDef === 'function'\n            ? resolvedDef\n            : _Vue.extend(resolvedDef)\n        // 赋值组件\n        // 如果组件全部解析完毕，继续下一步\n          match.components[key] = resolvedDef\n          pending--\n          if (pending <= 0) {\n            next()\n          }\n        })\n        // 失败回调\n        const reject = once(reason => {\n          const msg = `Failed to resolve async component ${key}: ${reason}`\n          process.env.NODE_ENV !== 'production' && warn(false, msg)\n          if (!error) {\n            error = isError(reason)\n              ? reason\n              : new Error(msg)\n            next(error)\n          }\n        })\n        let res\n        try {\n        // 执行异步组件函数\n          res = def(resolve, reject)\n        } catch (e) {\n          reject(e)\n        }\n        if (res) {\n        // 下载完成执行回调\n          if (typeof res.then === 'function') {\n            res.then(resolve, reject)\n          } else {\n            const comp = res.component\n            if (comp && typeof comp.then === 'function') {\n              comp.then(resolve, reject)\n            }\n          }\n        }\n      }\n    })\n    // 不是异步组件直接下一步\n    if (!hasAsync) next()\n  }\n}\n")])])]),r("p",[n._v("以上就是第一个 "),r("code",[n._v("runQueue")]),n._v(" 中的逻辑，第五步完成后会执行第一个 "),r("code",[n._v("runQueue")]),n._v(" 中回调函数")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("// 该回调用于保存 `beforeRouteEnter` 钩子中的回调函数\nconst postEnterCbs = []\nconst isValid = () => this.current === route\n// beforeRouteEnter 导航守卫钩子\nconst enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)\n// beforeResolve 导航守卫钩子\nconst queue = enterGuards.concat(this.router.resolveHooks)\nrunQueue(queue, iterator, () => {\n  if (this.pending !== route) {\n    return abort()\n  }\n  this.pending = null\n  // 这里会执行 afterEach 导航守卫钩子\n  onComplete(route)\n  if (this.router.app) {\n    this.router.app.$nextTick(() => {\n      postEnterCbs.forEach(cb => {\n        cb()\n      })\n    })\n  }\n})\n")])])]),r("p",[n._v("第六步是执行 "),r("code",[n._v("beforeRouteEnter")]),n._v(" 导航守卫钩子，"),r("code",[n._v("beforeRouteEnter")]),n._v(" 钩子不能访问 "),r("code",[n._v("this")]),n._v(" 对象，因为钩子在导航确认前被调用，需要渲染的组件还没被创建。但是该钩子函数是唯一一个支持在回调中获取 "),r("code",[n._v("this")]),n._v(" 对象的函数，回调会在路由确认执行。")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("beforeRouteEnter (to, from, next) {\n  next(vm => {\n    // 通过 `vm` 访问组件实例\n  })\n}\n")])])]),r("p",[n._v("下面来看看是如何支持在回调中拿到 "),r("code",[n._v("this")]),n._v(" 对象的")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("function extractEnterGuards(\n  activated: Array<RouteRecord>,\n  cbs: Array<Function>,\n  isValid: () => boolean\n): Array<?Function> {\n// 这里和之前调用导航守卫基本一致\n  return extractGuards(\n    activated,\n    'beforeRouteEnter',\n    (guard, _, match, key) => {\n      return bindEnterGuard(guard, match, key, cbs, isValid)\n    }\n  )\n}\nfunction bindEnterGuard(\n  guard: NavigationGuard,\n  match: RouteRecord,\n  key: string,\n  cbs: Array<Function>,\n  isValid: () => boolean\n): NavigationGuard {\n  return function routeEnterGuard(to, from, next) {\n    return guard(to, from, cb => {\n    // 判断 cb 是否是函数\n    // 是的话就 push 进 postEnterCbs\n      next(cb)\n      if (typeof cb === 'function') {\n        cbs.push(() => {\n          // 循环直到拿到组件实例\n          poll(cb, match.instances, key, isValid)\n        })\n      }\n    })\n  }\n}\n// 该函数是为了解决 issus #750\n// 当 router-view 外面包裹了 mode 为 out-in 的 transition 组件 \n// 会在组件初次导航到时获得不到组件实例对象\nfunction poll(\n  cb: any, // somehow flow cannot infer this is a function\n  instances: Object,\n  key: string,\n  isValid: () => boolean\n) {\n  if (\n    instances[key] &&\n    !instances[key]._isBeingDestroyed // do not reuse being destroyed instance\n  ) {\n    cb(instances[key])\n  } else if (isValid()) {\n  // setTimeout 16ms 作用和 nextTick 基本相同\n    setTimeout(() => {\n      poll(cb, instances, key, isValid)\n    }, 16)\n  }\n}\n")])])]),r("p",[n._v("第七步是执行 "),r("code",[n._v("beforeResolve")]),n._v(" 导航守卫钩子，如果注册了全局 "),r("code",[n._v("beforeResolve")]),n._v(" 钩子就会在这里执行。")]),r("p",[n._v("第八步就是导航确认，调用 "),r("code",[n._v("afterEach")]),n._v(" 导航守卫钩子了。")]),r("p",[n._v("以上都执行完成后，会触发组件的渲染")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("history.listen(route => {\n      this.apps.forEach(app => {\n        app._route = route\n      })\n})\n")])])]),r("p",[n._v("以上回调会在 "),r("code",[n._v("updateRoute")]),n._v(" 中调用")]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("updateRoute(route: Route) {\n    const prev = this.current\n    this.current = route\n    this.cb && this.cb(route)\n    this.router.afterHooks.forEach(hook => {\n      hook && hook(route, prev)\n    })\n}\n")])])]),r("p",[n._v("至此，路由跳转已经全部分析完毕。核心就是判断需要跳转的路由是否存在于记录中，然后执行各种导航守卫函数，最后完成 URL 的改变和组件的渲染。")]),r("p",[n._v("Now, let's try it 👉")])])}],o=t(0),a=Object(o.a)({},(function(){var n=this.$createElement;this._self._c;return this._m(0)}),r,!1,null,null,null);e.default=a.exports}}]);