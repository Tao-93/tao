(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{315:function(n,t,e){"use strict";e.r(t);var i=e(0),a=Object(i.a)({},(function(){var n=this.$createElement;this._self._c;return this._m(0)}),[function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"节流防抖"}},[n._v("节流防抖")]),e("h2",{attrs:{id:"节流"}},[n._v("节流")]),e("p",[n._v("防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait\n *\n * @param  {function}   func      回调函数\n * @param  {number}     wait      表示时间窗口的间隔\n * @param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。\n *                                如果想忽略结尾函数的调用，传入{trailing: false}\n *                                两者不能共存，否则函数不能执行\n * @return {function}             返回客户调用函数   \n */\n_.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    // 之前的时间戳\n    var previous = 0;\n    // 如果 options 没传则设为空对象\n    if (!options) options = {};\n    // 定时器回调函数\n    var later = function() {\n      // 如果设置了 leading，就将 previous 设为 0\n      // 用于下面函数的第一个 if 判断\n      previous = options.leading === false ? 0 : _.now();\n      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      // 获得当前时间戳\n      var now = _.now();\n      // 首次进入前者肯定为 true\n\t  // 如果需要第一次不执行函数\n\t  // 就将上次时间戳设为当前的\n      // 这样在接下来计算 remaining 的值时会大于0\n      if (!previous && options.leading === false) previous = now;\n      // 计算剩余时间\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      // 如果当前调用已经大于上次调用时间 + wait\n      // 或者用户手动调了时间\n \t  // 如果设置了 trailing，只会进入这个条件\n\t  // 如果没有设置 leading，那么第一次会进入这个条件\n\t  // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了\n\t  // 其实还是会进入的，因为定时器的延时\n\t  // 并不是准确的时间，很可能你设置了2秒\n\t  // 但是他需要2.2秒才触发，这时候就会进入这个条件\n      if (remaining <= 0 || remaining > wait) {\n        // 如果存在定时器就清理掉否则会调用二次回调\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        // 判断是否设置了定时器和 trailing\n\t    // 没有的话就开启一个定时器\n        // 并且不能不能同时设置 leading 和 trailing\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n")])])]),e("h2",{attrs:{id:"防抖"}},[n._v("防抖")]),e("p",[n._v("如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。")]),e("ul",[e("li",[n._v("对于按钮防点击来说的实现：一旦我开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 "),e("code",[n._v("null")]),n._v("，就可以再次点击了。")]),e("li",[n._v("对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数。")])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行\n *\n * @param  {function} func        回调函数\n * @param  {number}   wait        表示时间窗口的间隔\n * @param  {boolean}  immediate   设置为ture时，是否立即调用函数\n * @return {function}             返回客户调用函数\n */\n_.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      // 现在和上一次时间戳比较\n      var last = _.now() - timestamp;\n      // 如果当前间隔时间少于设定时间且大于0就重新设置定时器\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        // 否则的话就是时间到了执行回调函数\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      // 获得时间戳\n      timestamp = _.now();\n      // 如果定时器不存在且立即执行函数\n      var callNow = immediate && !timeout;\n      // 如果定时器不存在就创建一个\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        // 如果需要立即执行函数的话 通过 apply 执行\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n")])])]),e("p",[n._v("Now, let's try it 👉")])])}],!1,null,null,null);t.default=a.exports}}]);