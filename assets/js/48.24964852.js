(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{304:function(n,t,e){"use strict";e.r(t);var a=e(0),s=Object(a.a)({},(function(){var n=this.$createElement;this._self._c;return this._m(0)}),[function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"this"}},[n._v("this")]),e("h2",{attrs:{id:"js-里的-this"}},[n._v("JS 里的 this")]),e("ul",[e("li",[n._v("在 function 内部被创建")]),e("li",[n._v("指向调用时所在函数所绑定的对象")]),e("li",[n._v("this 不能被赋值，但可以被 call/apply  改变")])]),e("ol",[e("li",[n._v("全局作用域或者普通函数中this指向全局对象window。")]),e("li",[n._v("方法调用中谁调用this指向谁")]),e("li",[n._v("在构造函数或者构造函数原型对象中this指向构造函数的实例")])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function foo() {\n\tconsole.log(this.a)\n}\nvar a = 2\nfoo()\n\nvar obj = {\n\ta: 2,\n\tfoo: foo\n}\nobj.foo()\n\n// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况\n\n// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向\nvar c = new foo()\nc.a = 3\nconsole.log(c.a)\n\n// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new\n")])])]),e("p",[e("strong",[n._v("箭头函数中的 "),e("code",[n._v("this")])])]),e("p",[n._v("箭头函数中，this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function test() {\n    this.a = 22;\n    let b = function() {\n        console.log(this, this.a);   \n    };\n    b();\n}\ntest();  // window  , 22\nvar x = new test();  // window  , 11\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var a = 11;\nfunction test() {\n    this.a = 22;\n    let b = () => { console.log(this, this.a) }\n    b();\n};\ntest(); //window  , 22\nvar x = new test(); // test  , 22\n")])])]),e("p",[e("strong",[n._v("ES6中定义的时候绑定this的具体含义，应该继承的是父执行上下文里面的this，切忌是父执行上下文！")])]),e("p",[e("strong",[n._v("注意：简单对象（非函数）是没有执行上下文的！")])]),e("h2",{attrs:{id:"call-apply-bind"}},[n._v("call,apply,bind")]),e("p",[e("code",[n._v("call")]),n._v(" 和 "),e("code",[n._v("apply")]),n._v(" 都是为了解决改变 "),e("code",[n._v("this")]),n._v(" 的指向。")]),e("p",[n._v("作用都是相同的，只是传参的方式不同。除了第一个参数外，"),e("code",[n._v("call")]),n._v(" 可以接收一个参数列表，"),e("code",[n._v("apply")]),n._v(" 只接受一个参数数组。")]),e("p",[e("code",[n._v("bind")]),n._v("是新创建一个函数，然后把它的上下文绑定到bind()括号中的参数上，然后将它返回。")]),e("p",[n._v("所以，bind后函数不会执行，而只是返回一个改变了上下文的函数副本，而call和apply是直接执行函数。")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let a = {\n    value: 1\n}\nfunction getValue(name, age) {\n    console.log(name)\n    console.log(age)\n    console.log(this.value)\n}\ngetValue.call(a, 'yck', '24')\ngetValue.apply(a, ['yck', '24'])\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var obj = {\n    name: 'Dot'\n}\nfunction printName() {\n    console.log(this.name)\n}\nvar dot = printName.bind(obj)\nconsole.log(dot) // function () { … }\ndot()  // Dot\n")])])]),e("h3",{attrs:{id:"模拟实现call和bind"}},[n._v("模拟实现call和bind")]),e("p",[n._v("可以从以下几点来考虑如何实现")]),e("ul",[e("li",[n._v("不传入第一个参数，那么默认为 "),e("code",[n._v("window")])]),e("li",[n._v("改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？")])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Function.prototype.myCall = function (context) {\n  var context = context || window\n  // 给 context 添加一个属性\n  // getValue.call(a, 'yck', '24') => a.fn = getValue\n  context.fn = this\n  // 将 context 后面的参数取出来\n  var args = [...arguments].slice(1)\n  // getValue.call(a, 'yck', '24') => a.fn('yck', '24')\n  var result = context.fn(...args)\n  // 删除 fn\n  delete context.fn\n  return result\n}\n")])])]),e("p",[n._v("以上就是 "),e("code",[n._v("call")]),n._v(" 的思路，"),e("code",[n._v("apply")]),n._v(" 的实现也类似")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Function.prototype.myApply = function (context) {\n  var context = context || window\n  context.fn = this\n\n  var result\n  // 需要判断是否存储第二个参数\n  // 如果存在，就将第二个参数展开\n  if (arguments[1]) {\n    result = context.fn(...arguments[1])\n  } else {\n    result = context.fn()\n  }\n\n  delete context.fn\n  return result\n}\n")])])]),e("p",[e("code",[n._v("bind")]),n._v(" 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 "),e("code",[n._v("bind")]),n._v(" 实现柯里化。")]),e("p",[n._v("同样的，也来模拟实现下 "),e("code",[n._v("bind")])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Function.prototype.myBind = function (context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n  var _this = this\n  var args = [...arguments].slice(1)\n  // 返回一个函数\n  return function F() {\n    // 因为返回了一个函数，我们可以 new F()，所以需要判断\n    if (this instanceof F) {\n      return new _this(...args, ...arguments)\n    }\n    return _this.apply(context, args.concat(...arguments))\n  }\n}\n")])])]),e("p",[n._v("Now, let's try it 👉")])])}],!1,null,null,null);t.default=s.exports}}]);