(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{277:function(t,e,n){"use strict";n.r(e);var s=n(0),v=Object(s.a)({},(function(){var t=this.$createElement;this._self._c;return this._m(0)}),[function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"vue-vs-react"}},[t._v("VUE VS REACT")]),n("p",[n("strong",[t._v("相同点：")])]),n("p",[t._v("React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用。")]),n("p",[t._v("中心思想相同：一切都是组件，组件实例之间可以嵌套。 都提供合理的钩子函数，可以让开发者定制化地去处理需求。 都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载。")]),n("p",[t._v("虚拟dom减少对真实doom的操作。")]),n("p",[n("strong",[t._v("渲染问题")])]),n("p",[t._v("二者都是通过虚拟dom减少对真实doom的操作，但是vue实现的权重要轻的多。所以渲染用户界面的时候，vue的速度会更快一点。")]),n("p",[n("strong",[t._v("更新性能")]),t._v(" 在react中，当一个组件的状态发生变化时，它将会引起整个组件的子树都进行重新渲染，从这个组件的根部开始。在Vue中，组件的依赖关系在它的渲染期间被自动跟踪，因此系统准确地知道哪些组件实际上需要重新渲染。这就意味着在更新方面,vue也是快于React")]),n("p",[n("strong",[t._v("规模方面")]),t._v(" Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的 React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。")])])}],!1,null,null,null);e.default=v.exports}}]);