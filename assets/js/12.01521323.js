(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{231:function(e,n,t){e.exports=t.p+"assets/img/vue_01.6f2c97f0.png"},288:function(e,n,t){"use strict";t.r(n);var o=[function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("div",{staticClass:"content"},[o("h1",{attrs:{id:"生命周期"}},[e._v("生命周期")]),o("p",[o("img",{attrs:{src:t(231),alt:""}})]),o("p",[e._v("在初始化时，会调用以下代码，生命周期就是通过 "),o("code",[e._v("callHook")]),e._v(" 调用的")]),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("Vue.prototype._init = function(options) {\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate') // 拿不到 props data\n    initInjections(vm) \n    initState(vm)\n    initProvide(vm)\n    callHook(vm, 'created')\n}\n")])])]),o("p",[e._v("可以发现在以上代码中，"),o("strong",[o("code",[e._v("beforeCreate")]),e._v(" 调用的时候，是获取不到 props 或者 data 中的数据")]),e._v("的，因为这些数据的初始化都在 "),o("code",[e._v("initState")]),e._v(" 中。")]),o("p",[o("strong",[e._v("此时还是没有el")]),e._v("选项")]),o("p",[e._v("接下来会执行挂载函数")]),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("export function mountComponent {\n    callHook(vm, 'beforeMount')\n    // ...\n    if (vm.$vnode == null) {\n        vm._isMounted = true\n        callHook(vm, 'mounted')\n    }\n}\n")])])]),o("p",[o("strong",[o("code",[e._v("beforeMount")]),e._v(" 就是在挂载前执行的，然后开始创建 VDOM 并替换成真实 DOM")]),e._v("，最后执行 "),o("code",[e._v("mounted")]),e._v(" 钩子。这里会有个判断逻辑，如果是外部 "),o("code",[e._v("new Vue({})")]),e._v(" 的话，不会存在 "),o("code",[e._v("$vnode")]),e._v(" ，所以直接执行 "),o("code",[e._v("mounted")]),e._v(" 钩子了。如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。")]),o("p",[e._v("接下来是数据更新时会调用的钩子函数")]),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("function flushSchedulerQueue() {\n  // ...\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index]\n    if (watcher.before) {\n      watcher.before() // 调用 beforeUpdate\n    }\n    id = watcher.id\n    has[id] = null\n    watcher.run()\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' +\n            (watcher.user\n              ? `in watcher with expression \"${watcher.expression}\"`\n              : `in a component render function.`),\n          watcher.vm\n        )\n        break\n      }\n    }\n  }\n  callUpdatedHooks(updatedQueue)\n}\n\nfunction callUpdatedHooks(queue) {\n  let i = queue.length\n  while (i--) {\n    const watcher = queue[i]\n    const vm = watcher.vm\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated')\n    }\n  }\n}\n")])])]),o("p",[e._v("上图还有两个生命周期没有说，分别为 "),o("code",[e._v("activated")]),e._v(" 和 "),o("code",[e._v("deactivated")]),e._v(" ，这两个钩子函数是 "),o("code",[e._v("keep-alive")]),e._v(" 组件独有的。用 "),o("code",[e._v("keep-alive")]),e._v(" 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 "),o("code",[e._v("deactivated")]),e._v(" 钩子函数，命中缓存渲染后会执行 "),o("code",[e._v("actived")]),e._v(" 钩子函数。")]),o("p",[e._v("最后就是销毁组件的钩子函数了")]),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("Vue.prototype.$destroy = function() {\n  // ...\n  callHook(vm, 'beforeDestroy')\n  vm._isBeingDestroyed = true\n  // remove self from parent\n  const parent = vm.$parent\n  if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n    remove(parent.$children, vm)\n  }\n  // teardown watchers\n  if (vm._watcher) {\n    vm._watcher.teardown()\n  }\n  let i = vm._watchers.length\n  while (i--) {\n    vm._watchers[i].teardown()\n  }\n  // remove reference from data ob\n  // frozen object may not have observer.\n  if (vm._data.__ob__) {\n    vm._data.__ob__.vmCount--\n  }\n  // call the last hook...\n  vm._isDestroyed = true\n  // invoke destroy hooks on current rendered tree\n  vm.__patch__(vm._vnode, null)\n  // fire destroyed hook\n  callHook(vm, 'destroyed')\n  // turn off all instance listeners.\n  vm.$off()\n  // remove __vue__ reference\n  if (vm.$el) {\n    vm.$el.__vue__ = null\n  }\n  // release circular reference (##6759)\n  if (vm.$vnode) {\n    vm.$vnode.parent = null\n  }\n}\n")])])]),o("p",[e._v("在执行销毁操作前会调用 "),o("strong",[o("code",[e._v("beforeDestroy")]),e._v(" 钩子函数，在这一步，实例仍然完全可用")]),e._v("。  然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 "),o("code",[e._v("destroyed")]),e._v(" 钩子函数。")]),o("p",[o("strong",[e._v("beforeCreate：")]),e._v(" loading事件，"),o("br"),o("strong",[e._v("created：")]),e._v("  可以进行Ajax请求取回数据 ，获取到data"),o("br"),o("strong",[e._v("beforeMount：")]),e._v(" 始创建 VDOM"),o("br"),o("strong",[e._v("mounted：")]),e._v(" 挂载元素，获取dom节点"),o("br"),o("strong",[e._v("beforeUpdate：")]),o("br"),o("strong",[e._v("updated：")]),e._v(" 如果对数据统一处理，在这里写上相应函数"),o("br"),o("strong",[e._v("beforeDestory：")]),e._v(" 可以做一个确认停止事件的确认框"),o("br"),o("strong",[e._v("destoryed：")]),e._v(" 销毁")]),o("p",[e._v("Now, let's try it 👉")])])}],r=t(0),a=Object(r.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),o,!1,null,null,null);n.default=a.exports}}]);