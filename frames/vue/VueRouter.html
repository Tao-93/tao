<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VueRouter | AlexTao 的 博客</title>
    <meta name="description" content="In doing we learn.">
    <link rel="icon" href="favicon.ico">
    
    <link rel="preload" href="/Weblog/assets/css/styles.05873600.css" as="style"><link rel="preload" href="/Weblog/assets/js/app.05873600.js" as="script"><link rel="preload" href="/Weblog/assets/js/11.d51cd775.js" as="script"><link rel="prefetch" href="/Weblog/assets/css/16.styles.2339a627.css"><link rel="prefetch" href="/Weblog/assets/css/5.styles.c1152841.css"><link rel="prefetch" href="/Weblog/assets/css/7.styles.1f4a6057.css"><link rel="prefetch" href="/Weblog/assets/css/8.styles.5b6e1357.css"><link rel="prefetch" href="/Weblog/assets/js/0.a8dcd889.js"><link rel="prefetch" href="/Weblog/assets/js/10.fe0f74e6.js"><link rel="prefetch" href="/Weblog/assets/js/12.01521323.js"><link rel="prefetch" href="/Weblog/assets/js/13.82c3fc4a.js"><link rel="prefetch" href="/Weblog/assets/js/14.3b16e4be.js"><link rel="prefetch" href="/Weblog/assets/js/15.abf2374c.js"><link rel="prefetch" href="/Weblog/assets/js/16.2339a627.js"><link rel="prefetch" href="/Weblog/assets/js/17.f68b5694.js"><link rel="prefetch" href="/Weblog/assets/js/18.1dc877c8.js"><link rel="prefetch" href="/Weblog/assets/js/19.8d3a8eb9.js"><link rel="prefetch" href="/Weblog/assets/js/2.af3ad6a4.js"><link rel="prefetch" href="/Weblog/assets/js/20.b49a1359.js"><link rel="prefetch" href="/Weblog/assets/js/21.791ceaa2.js"><link rel="prefetch" href="/Weblog/assets/js/22.fc4cbaec.js"><link rel="prefetch" href="/Weblog/assets/js/23.4ad12214.js"><link rel="prefetch" href="/Weblog/assets/js/24.55bc5812.js"><link rel="prefetch" href="/Weblog/assets/js/25.f985eed7.js"><link rel="prefetch" href="/Weblog/assets/js/26.4cb7663f.js"><link rel="prefetch" href="/Weblog/assets/js/27.a14669b1.js"><link rel="prefetch" href="/Weblog/assets/js/28.8620d72f.js"><link rel="prefetch" href="/Weblog/assets/js/29.d0f2b69c.js"><link rel="prefetch" href="/Weblog/assets/js/3.fb06d288.js"><link rel="prefetch" href="/Weblog/assets/js/30.779bb068.js"><link rel="prefetch" href="/Weblog/assets/js/31.40c7de84.js"><link rel="prefetch" href="/Weblog/assets/js/32.ba7c27f0.js"><link rel="prefetch" href="/Weblog/assets/js/33.6ab2c1a8.js"><link rel="prefetch" href="/Weblog/assets/js/34.e8c873d7.js"><link rel="prefetch" href="/Weblog/assets/js/35.e96a75ad.js"><link rel="prefetch" href="/Weblog/assets/js/36.86fbcd91.js"><link rel="prefetch" href="/Weblog/assets/js/37.b26a2882.js"><link rel="prefetch" href="/Weblog/assets/js/38.992c347d.js"><link rel="prefetch" href="/Weblog/assets/js/39.e58d8f81.js"><link rel="prefetch" href="/Weblog/assets/js/4.b91b4b8a.js"><link rel="prefetch" href="/Weblog/assets/js/40.01c8b7bc.js"><link rel="prefetch" href="/Weblog/assets/js/41.75147100.js"><link rel="prefetch" href="/Weblog/assets/js/42.b2377431.js"><link rel="prefetch" href="/Weblog/assets/js/43.3a184450.js"><link rel="prefetch" href="/Weblog/assets/js/44.067bcf22.js"><link rel="prefetch" href="/Weblog/assets/js/45.68ba4476.js"><link rel="prefetch" href="/Weblog/assets/js/46.78e6e5f5.js"><link rel="prefetch" href="/Weblog/assets/js/47.08c79ff4.js"><link rel="prefetch" href="/Weblog/assets/js/48.24964852.js"><link rel="prefetch" href="/Weblog/assets/js/49.e7608465.js"><link rel="prefetch" href="/Weblog/assets/js/5.c1152841.js"><link rel="prefetch" href="/Weblog/assets/js/50.35c99ad9.js"><link rel="prefetch" href="/Weblog/assets/js/51.6b5dac05.js"><link rel="prefetch" href="/Weblog/assets/js/52.c4bb9237.js"><link rel="prefetch" href="/Weblog/assets/js/53.e53dd56d.js"><link rel="prefetch" href="/Weblog/assets/js/54.b8170212.js"><link rel="prefetch" href="/Weblog/assets/js/55.3f8a7f90.js"><link rel="prefetch" href="/Weblog/assets/js/56.70171628.js"><link rel="prefetch" href="/Weblog/assets/js/57.bfaf61b1.js"><link rel="prefetch" href="/Weblog/assets/js/58.db4b1b8a.js"><link rel="prefetch" href="/Weblog/assets/js/59.77684353.js"><link rel="prefetch" href="/Weblog/assets/js/6.829d0e7e.js"><link rel="prefetch" href="/Weblog/assets/js/60.6e9d6cac.js"><link rel="prefetch" href="/Weblog/assets/js/61.275c3154.js"><link rel="prefetch" href="/Weblog/assets/js/62.dd80ea43.js"><link rel="prefetch" href="/Weblog/assets/js/63.dbe8bf46.js"><link rel="prefetch" href="/Weblog/assets/js/64.14e4d91c.js"><link rel="prefetch" href="/Weblog/assets/js/65.c15a382b.js"><link rel="prefetch" href="/Weblog/assets/js/66.1eb3e94c.js"><link rel="prefetch" href="/Weblog/assets/js/67.3ae69c25.js"><link rel="prefetch" href="/Weblog/assets/js/68.2e02b211.js"><link rel="prefetch" href="/Weblog/assets/js/69.2016bf42.js"><link rel="prefetch" href="/Weblog/assets/js/7.1f4a6057.js"><link rel="prefetch" href="/Weblog/assets/js/70.8e2ebe5b.js"><link rel="prefetch" href="/Weblog/assets/js/8.5b6e1357.js"><link rel="prefetch" href="/Weblog/assets/js/9.93970f24.js">
    <link rel="stylesheet" href="/Weblog/assets/css/styles.05873600.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/Weblog/" class="home-link router-link-active"><!----><span class="site-name">
      AlexTao 的 博客
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/Weblog/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Classify</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/Weblog/html_css/" class="nav-link">HTML/CSS</a></li><li class="dropdown-item"><!----><a href="/Weblog/javascript/" class="nav-link">Javascript</a></li><li class="dropdown-item"><!----><a href="/Weblog/node/" class="nav-link">Node.js</a></li><li class="dropdown-item"><!----><a href="/Weblog/frames/" class="nav-link router-link-active">Frames</a></li><li class="dropdown-item"><!----><a href="/Weblog/tool/" class="nav-link">Tool</a></li><li class="dropdown-item"><!----><a href="/Weblog/currency/" class="nav-link">Currency</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/AlexTaoClub" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Weblog/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Classify</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/Weblog/html_css/" class="nav-link">HTML/CSS</a></li><li class="dropdown-item"><!----><a href="/Weblog/javascript/" class="nav-link">Javascript</a></li><li class="dropdown-item"><!----><a href="/Weblog/node/" class="nav-link">Node.js</a></li><li class="dropdown-item"><!----><a href="/Weblog/frames/" class="nav-link router-link-active">Frames</a></li><li class="dropdown-item"><!----><a href="/Weblog/tool/" class="nav-link">Tool</a></li><li class="dropdown-item"><!----><a href="/Weblog/currency/" class="nav-link">Currency</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/AlexTaoClub" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>Vue</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/Weblog/frames/vue/" aria-current="page" class="sidebar-link">数据原理</a></li><li><a href="/Weblog/frames/vue/生命周期.html" class="sidebar-link">生命周期</a></li><li><a href="/Weblog/frames/vue/template.html" class="sidebar-link">template理解</a></li><li><a href="/Weblog/frames/vue/NextTick.html" class="sidebar-link">NextTick</a></li><li><a href="/Weblog/frames/vue/VueRouter.html" aria-current="page" class="active sidebar-link">VueRouter</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Weblog/frames/vue/VueRouter.html#路由注册" class="sidebar-link">路由注册</a></li><li class="sidebar-sub-header"><a href="/Weblog/frames/vue/VueRouter.html#vuerouter实例化" class="sidebar-link">VueRouter实例化</a></li><li class="sidebar-sub-header"><a href="/Weblog/frames/vue/VueRouter.html#创建路由匹配对象" class="sidebar-link">创建路由匹配对象</a></li><li class="sidebar-sub-header"><a href="/Weblog/frames/vue/VueRouter.html#路由初始化" class="sidebar-link">路由初始化</a></li><li class="sidebar-sub-header"><a href="/Weblog/frames/vue/VueRouter.html#路由跳转" class="sidebar-link">路由跳转</a></li></ul></li><li><a href="/Weblog/frames/vue/登录拦截逻辑.html" class="sidebar-link">登录拦截逻辑</a></li><li><a href="/Weblog/frames/vue/路由跳转传参.html" class="sidebar-link">路由跳转传参</a></li><li><a href="/Weblog/frames/vue/组件通信.html" class="sidebar-link">组件通信 </a></li><li><a href="/Weblog/frames/vue/父子组件数据双向绑定.html" class="sidebar-link">父子组件数据双向绑定</a></li><li><a href="/Weblog/frames/vue/VUEX.html" class="sidebar-link">VUEX</a></li><li><a href="/Weblog/frames/vue/vue-property-decorator.html" class="sidebar-link">vue-property-decorator</a></li><li><a href="/Weblog/frames/vue/TslintOfVue.html" class="sidebar-link">Tslint.json配置</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>React</span><span class="arrow right"></span></p><!----></div></li></ul></div><div class="page"><div class="content"><h1 id="vuerouter">VueRouter</h1><h3 id="重要函数思维导图">重要函数思维导图</h3><p>以下思维导图罗列了源码中重要的一些函数 <img src="/Weblog/assets/img/vue_02.5b4ddc25.png" alt="img"></p><h2 id="路由注册">路由注册</h2><p>在开始之前，推荐大家 clone 一份源码对照着看。因为篇幅较长，函数间的跳转也很多。</p><p>使用路由之前，需要调用 <code>Vue.use(VueRouter)</code>，这是因为让插件可以使用 Vue</p><div class="language- extra-class"><pre class="language-text"><code>export function initUse (Vue: GlobalAPI) {
  Vue.use = function (plugin: Function | Object) {
    // 判断重复安装插件
    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))
    if (installedPlugins.indexOf(plugin) &gt; -1) {
      return this
    }
    const args = toArray(arguments, 1)
    // 插入 Vue
    args.unshift(this)
    // 一般插件都会有一个 install 函数
    // 通过该函数让插件可以使用 Vue
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args)
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args)
    }
    installedPlugins.push(plugin)
    return this
  }
}
</code></pre></div><p>接下来看下 <code>install</code> 函数的部分实现</p><div class="language- extra-class"><pre class="language-text"><code>export function install (Vue) {
  // 确保 install 调用一次
  if (install.installed &amp;&amp; _Vue === Vue) return
  install.installed = true
  // 把 Vue 赋值给全局变量
  _Vue = Vue
  const registerInstance = (vm, callVal) =&gt; {
    let i = vm.$options._parentVnode
    if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) {
      i(vm, callVal)
    }
  }
  // 给每个组件的钩子函数混入实现
  // 可以发现在 `beforeCreate` 钩子执行时
  // 会初始化路由
  Vue.mixin({
    beforeCreate () {
      // 判断组件是否存在 router 对象，该对象只在根组件上有
      if (isDef(this.$options.router)) {
        // 根路由设置为自己
        this._routerRoot = this
        this._router = this.$options.router
        // 初始化路由
        this._router.init(this)
        // 很重要，为 _route 属性实现双向绑定
        // 触发组件渲染
        Vue.util.defineReactive(this, '_route', this._router.history.current)
      } else {
        // 用于 router-view 层级判断
        this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this
      }
      registerInstance(this, this)
    },
    destroyed () {
      registerInstance(this)
    }
  })
  // 全局注册组件 router-link 和 router-view
  Vue.component('RouterView', View)
  Vue.component('RouterLink', Link)
}
</code></pre></div><p>对于路由注册来说，核心就是调用 <code>Vue.use(VueRouter)</code>，使得 VueRouter 可以使用 Vue。然后通过 Vue 来调用 VueRouter 的 <code>install</code> 函数。在该函数中，核心就是给组件混入钩子函数和全局注册两个路由组件。</p><h2 id="vuerouter实例化">VueRouter实例化</h2><p>在安装插件后，对 VueRouter 进行实例化。</p><div class="language- extra-class"><pre class="language-text"><code>const Home = { template: '&lt;div&gt;home&lt;/div&gt;' }
const Foo = { template: '&lt;div&gt;foo&lt;/div&gt;' }
const Bar = { template: '&lt;div&gt;bar&lt;/div&gt;' }

// 3. Create the router
const router = new VueRouter({
  mode: 'hash',
  base: __dirname,
  routes: [
    { path: '/', component: Home }, // all paths are defined without the hash.
    { path: '/foo', component: Foo },
    { path: '/bar', component: Bar }
  ]
})
</code></pre></div><p>来看一下 VueRouter 的构造函数</p><div class="language- extra-class"><pre class="language-text"><code>constructor(options: RouterOptions = {}) {
    // ...
    // 路由匹配对象
    this.matcher = createMatcher(options.routes || [], this)

    // 根据 mode 采取不同的路由方式
    let mode = options.mode || 'hash'
    this.fallback =
      mode === 'history' &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false
    if (this.fallback) {
      mode = 'hash'
    }
    if (!inBrowser) {
      mode = 'abstract'
    }
    this.mode = mode

    switch (mode) {
      case 'history':
        this.history = new HTML5History(this, options.base)
        break
      case 'hash':
        this.history = new HashHistory(this, options.base, this.fallback)
        break
      case 'abstract':
        this.history = new AbstractHistory(this, options.base)
        break
      default:
        if (process.env.NODE_ENV !== 'production') {
          assert(false, `invalid mode: ${mode}`)
        }
    }
  }
</code></pre></div><p>在实例化 VueRouter 的过程中，核心是创建一个路由匹配对象，并且根据 mode 来采取不同的路由方式。</p><h2 id="创建路由匹配对象">创建路由匹配对象</h2><div class="language- extra-class"><pre class="language-text"><code>export function createMatcher (
  routes: Array&lt;RouteConfig&gt;,
  router: VueRouter
): Matcher {
    // 创建路由映射表
  const { pathList, pathMap, nameMap } = createRouteMap(routes)
    
  function addRoutes (routes) {
    createRouteMap(routes, pathList, pathMap, nameMap)
  }
  // 路由匹配
  function match (
    raw: RawLocation,
    currentRoute?: Route,
    redirectedFrom?: Location
  ): Route {
    //...
  }

  return {
    match,
    addRoutes
  }
}
</code></pre></div><p><code>createMatcher</code> 函数的作用就是创建路由映射表，然后通过闭包的方式让 <code>addRoutes</code> 和 <code>match</code> 函数能够使用路由映射表的几个对象，最后返回一个 <code>Matcher</code> 对象。</p><p>接下来看 <code>createMatcher</code> 函数时如何创建映射表的</p><div class="language- extra-class"><pre class="language-text"><code>export function createRouteMap (
  routes: Array&lt;RouteConfig&gt;,
  oldPathList?: Array&lt;string&gt;,
  oldPathMap?: Dictionary&lt;RouteRecord&gt;,
  oldNameMap?: Dictionary&lt;RouteRecord&gt;
): {
  pathList: Array&lt;string&gt;;
  pathMap: Dictionary&lt;RouteRecord&gt;;
  nameMap: Dictionary&lt;RouteRecord&gt;;
} {
  // 创建映射表
  const pathList: Array&lt;string&gt; = oldPathList || []
  const pathMap: Dictionary&lt;RouteRecord&gt; = oldPathMap || Object.create(null)
  const nameMap: Dictionary&lt;RouteRecord&gt; = oldNameMap || Object.create(null)
  // 遍历路由配置，为每个配置添加路由记录
  routes.forEach(route =&gt; {
    addRouteRecord(pathList, pathMap, nameMap, route)
  })
  // 确保通配符在最后
  for (let i = 0, l = pathList.length; i &lt; l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0])
      l--
      i--
    }
  }
  return {
    pathList,
    pathMap,
    nameMap
  }
}
// 添加路由记录
function addRouteRecord (
  pathList: Array&lt;string&gt;,
  pathMap: Dictionary&lt;RouteRecord&gt;,
  nameMap: Dictionary&lt;RouteRecord&gt;,
  route: RouteConfig,
  parent?: RouteRecord,
  matchAs?: string
) {
  // 获得路由配置下的属性
  const { path, name } = route
  const pathToRegexpOptions: PathToRegexpOptions = route.pathToRegexpOptions || {}
  // 格式化 url，替换 / 
  const normalizedPath = normalizePath(
    path,
    parent,
    pathToRegexpOptions.strict
  )
  // 生成记录对象
  const record: RouteRecord = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name,
    parent,
    matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null
      ? {}
      : route.components
        ? route.props
        : { default: route.props }
  }

  if (route.children) {
    // 递归路由配置的 children 属性，添加路由记录
    route.children.forEach(child =&gt; {
      const childMatchAs = matchAs
        ? cleanPath(`${matchAs}/${child.path}`)
        : undefined
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs)
    })
  }
  // 如果路由有别名的话
  // 给别名也添加路由记录
  if (route.alias !== undefined) {
    const aliases = Array.isArray(route.alias)
      ? route.alias
      : [route.alias]

    aliases.forEach(alias =&gt; {
      const aliasRoute = {
        path: alias,
        children: route.children
      }
      addRouteRecord(
        pathList,
        pathMap,
        nameMap,
        aliasRoute,
        parent,
        record.path || '/' // matchAs
      )
    })
  }
  // 更新映射表
  if (!pathMap[record.path]) {
    pathList.push(record.path)
    pathMap[record.path] = record
  }
  // 命名路由添加记录
  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record
    } else if (process.env.NODE_ENV !== 'production' &amp;&amp; !matchAs) {
      warn(
        false,
        `Duplicate named routes definition: ` +
        `{ name: &quot;${name}&quot;, path: &quot;${record.path}&quot; }`
      )
    }
  }
}
</code></pre></div><p>以上就是创建路由匹配对象的全过程，通过用户配置的路由规则来创建对应的路由映射表。</p><h2 id="路由初始化">路由初始化</h2><p>当根组件调用 <code>beforeCreate</code> 钩子函数时，会执行以下代码</p><div class="language- extra-class"><pre class="language-text"><code>beforeCreate () {
// 只有根组件有 router 属性，所以根组件初始化时会初始化路由
  if (isDef(this.$options.router)) {
    this._routerRoot = this
    this._router = this.$options.router
    this._router.init(this)
    Vue.util.defineReactive(this, '_route', this._router.history.current)
  } else {
    this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this
  }
  registerInstance(this, this)
}
</code></pre></div><p>接下来看下路由初始化会做些什么</p><div class="language- extra-class"><pre class="language-text"><code>init(app: any /* Vue component instance */) {
    // 保存组件实例
    this.apps.push(app)
    // 如果根组件已经有了就返回
    if (this.app) {
      return
    }
    this.app = app
    // 赋值路由模式
    const history = this.history
    // 判断路由模式，以哈希模式为例
    if (history instanceof HTML5History) {
      history.transitionTo(history.getCurrentLocation())
    } else if (history instanceof HashHistory) {
      // 添加 hashchange 监听
      const setupHashListener = () =&gt; {
        history.setupListeners()
      }
      // 路由跳转
      history.transitionTo(
        history.getCurrentLocation(),
        setupHashListener,
        setupHashListener
      )
    }
    // 该回调会在 transitionTo 中调用
    // 对组件的 _route 属性进行赋值，触发组件渲染
    history.listen(route =&gt; {
      this.apps.forEach(app =&gt; {
        app._route = route
      })
    })
  }
</code></pre></div><p>在路由初始化时，核心就是进行路由的跳转，改变 URL 然后渲染对应的组件。接下来来看一下路由是如何进行跳转的。</p><h2 id="路由跳转">路由跳转</h2><div class="language- extra-class"><pre class="language-text"><code>transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {
  // 获取匹配的路由信息
  const route = this.router.match(location, this.current)
  // 确认切换路由
  this.confirmTransition(route, () =&gt; {
    // 以下为切换路由成功或失败的回调
    // 更新路由信息，对组件的 _route 属性进行赋值，触发组件渲染
    // 调用 afterHooks 中的钩子函数
    this.updateRoute(route)
    // 添加 hashchange 监听
    onComplete &amp;&amp; onComplete(route)
    // 更新 URL
    this.ensureURL()
    // 只执行一次 ready 回调
    if (!this.ready) {
      this.ready = true
      this.readyCbs.forEach(cb =&gt; { cb(route) })
    }
  }, err =&gt; {
  // 错误处理
    if (onAbort) {
      onAbort(err)
    }
    if (err &amp;&amp; !this.ready) {
      this.ready = true
      this.readyErrorCbs.forEach(cb =&gt; { cb(err) })
    }
  })
}
</code></pre></div><p>在路由跳转中，需要先获取匹配的路由信息，所以先来看下如何获取匹配的路由信息</p><div class="language- extra-class"><pre class="language-text"><code>function match (
  raw: RawLocation,
  currentRoute?: Route,
  redirectedFrom?: Location
): Route {
  // 序列化 url
  // 比如对于该 url 来说 /abc?foo=bar&amp;baz=qux#hello
  // 会序列化路径为 /abc
  // 哈希为 #hello
  // 参数为 foo: 'bar', baz: 'qux'
  const location = normalizeLocation(raw, currentRoute, false, router)
  const { name } = location
  // 如果是命名路由，就判断记录中是否有该命名路由配置
  if (name) {
    const record = nameMap[name]
    // 没找到表示没有匹配的路由
    if (!record) return _createRoute(null, location)
    const paramNames = record.regex.keys
      .filter(key =&gt; !key.optional)
      .map(key =&gt; key.name)
    // 参数处理
    if (typeof location.params !== 'object') {
      location.params = {}
    }
    if (currentRoute &amp;&amp; typeof currentRoute.params === 'object') {
      for (const key in currentRoute.params) {
        if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) {
          location.params[key] = currentRoute.params[key]
        }
      }
    }
    if (record) {
      location.path = fillParams(record.path, location.params, `named route &quot;${name}&quot;`)
      return _createRoute(record, location, redirectedFrom)
    }
  } else if (location.path) {
    // 非命名路由处理
    location.params = {}
    for (let i = 0; i &lt; pathList.length; i++) {
     // 查找记录
      const path = pathList[i]
      const record = pathMap[path]
      // 如果匹配路由，则创建路由
      if (matchRoute(record.regex, location.path, location.params)) {
        return _createRoute(record, location, redirectedFrom)
      }
    }
  }
  // 没有匹配的路由
  return _createRoute(null, location)
}
</code></pre></div><p>接下来看看如何创建路由</p><div class="language- extra-class"><pre class="language-text"><code>// 根据条件创建不同的路由
function _createRoute(
  record: ?RouteRecord,
  location: Location,
  redirectedFrom?: Location
): Route {
  if (record &amp;&amp; record.redirect) {
    return redirect(record, redirectedFrom || location)
  }
  if (record &amp;&amp; record.matchAs) {
    return alias(record, location, record.matchAs)
  }
  return createRoute(record, location, redirectedFrom, router)
}

export function createRoute (
  record: ?RouteRecord,
  location: Location,
  redirectedFrom?: ?Location,
  router?: VueRouter
): Route {
  const stringifyQuery = router &amp;&amp; router.options.stringifyQuery
  // 克隆参数
  let query: any = location.query || {}
  try {
    query = clone(query)
  } catch (e) {}
  // 创建路由对象
  const route: Route = {
    name: location.name || (record &amp;&amp; record.name),
    meta: (record &amp;&amp; record.meta) || {},
    path: location.path || '/',
    hash: location.hash || '',
    query,
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery),
    matched: record ? formatMatch(record) : []
  }
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery)
  }
  // 让路由对象不可修改
  return Object.freeze(route)
}
// 获得包含当前路由的所有嵌套路径片段的路由记录
// 包含从根路由到当前路由的匹配记录，从上至下
function formatMatch(record: ?RouteRecord): Array&lt;RouteRecord&gt; {
  const res = []
  while (record) {
    res.unshift(record)
    record = record.parent
  }
  return res
}
</code></pre></div><p>至此匹配路由已经完成，我们回到 <code>transitionTo</code> 函数中，接下来执行 <code>confirmTransition</code></p><div class="language- extra-class"><pre class="language-text"><code>transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {
  // 确认切换路由
  this.confirmTransition(route, () =&gt; {}
}
confirmTransition(route: Route, onComplete: Function, onAbort?: Function) {
  const current = this.current
  // 中断跳转路由函数
  const abort = err =&gt; {
    if (isError(err)) {
      if (this.errorCbs.length) {
        this.errorCbs.forEach(cb =&gt; {
          cb(err)
        })
      } else {
        warn(false, 'uncaught error during route navigation:')
        console.error(err)
      }
    }
    onAbort &amp;&amp; onAbort(err)
  }
  // 如果是相同的路由就不跳转
  if (
    isSameRoute(route, current) &amp;&amp;
    route.matched.length === current.matched.length
  ) {
    this.ensureURL()
    return abort()
  }
  // 通过对比路由解析出可复用的组件，需要渲染的组件，失活的组件
  const { updated, deactivated, activated } = resolveQueue(
    this.current.matched,
    route.matched
  )
  
  function resolveQueue(
      current: Array&lt;RouteRecord&gt;,
      next: Array&lt;RouteRecord&gt;
    ): {
      updated: Array&lt;RouteRecord&gt;,
      activated: Array&lt;RouteRecord&gt;,
      deactivated: Array&lt;RouteRecord&gt;
    } {
      let i
      const max = Math.max(current.length, next.length)
      for (i = 0; i &lt; max; i++) {
        // 当前路由路径和跳转路由路径不同时跳出遍历
        if (current[i] !== next[i]) {
          break
        }
      }
      return {
        // 可复用的组件对应路由
        updated: next.slice(0, i),
        // 需要渲染的组件对应路由
        activated: next.slice(i),
        // 失活的组件对应路由
        deactivated: current.slice(i)
      }
  }
  // 导航守卫数组
  const queue: Array&lt;?NavigationGuard&gt; = [].concat(
    // 失活的组件钩子
    extractLeaveGuards(deactivated),
    // 全局 beforeEach 钩子
    this.router.beforeHooks,
    // 在当前路由改变，但是该组件被复用时调用
    extractUpdateHooks(updated),
    // 需要渲染组件 enter 守卫钩子
    activated.map(m =&gt; m.beforeEnter),
    // 解析异步路由组件
    resolveAsyncComponents(activated)
  )
  // 保存路由
  this.pending = route
  // 迭代器，用于执行 queue 中的导航守卫钩子
  const iterator = (hook: NavigationGuard, next) =&gt; {
  // 路由不相等就不跳转路由
    if (this.pending !== route) {
      return abort()
    }
    try {
    // 执行钩子
      hook(route, current, (to: any) =&gt; {
        // 只有执行了钩子函数中的 next，才会继续执行下一个钩子函数
        // 否则会暂停跳转
        // 以下逻辑是在判断 next() 中的传参
        if (to === false || isError(to)) {
          // next(false) 
          this.ensureURL(true)
          abort(to)
        } else if (
          typeof to === 'string' ||
          (typeof to === 'object' &amp;&amp;
            (typeof to.path === 'string' || typeof to.name === 'string'))
        ) {
        // next('/') 或者 next({ path: '/' }) -&gt; 重定向
          abort()
          if (typeof to === 'object' &amp;&amp; to.replace) {
            this.replace(to)
          } else {
            this.push(to)
          }
        } else {
        // 这里执行 next
        // 也就是执行下面函数 runQueue 中的 step(index + 1)
          next(to)
        }
      })
    } catch (e) {
      abort(e)
    }
  }
  // 经典的同步执行异步函数
  runQueue(queue, iterator, () =&gt; {
    const postEnterCbs = []
    const isValid = () =&gt; this.current === route
    // 当所有异步组件加载完成后，会执行这里的回调，也就是 runQueue 中的 cb()
    // 接下来执行 需要渲染组件的导航守卫钩子
    const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)
    const queue = enterGuards.concat(this.router.resolveHooks)
    runQueue(queue, iterator, () =&gt; {
    // 跳转完成
      if (this.pending !== route) {
        return abort()
      }
      this.pending = null
      onComplete(route)
      if (this.router.app) {
        this.router.app.$nextTick(() =&gt; {
          postEnterCbs.forEach(cb =&gt; {
            cb()
          })
        })
      }
    })
  })
}
export function runQueue (queue: Array&lt;?NavigationGuard&gt;, fn: Function, cb: Function) {
  const step = index =&gt; {
  // 队列中的函数都执行完毕，就执行回调函数
    if (index &gt;= queue.length) {
      cb()
    } else {
      if (queue[index]) {
      // 执行迭代器，用户在钩子函数中执行 next() 回调
      // 回调中判断传参，没有问题就执行 next()，也就是 fn 函数中的第二个参数
        fn(queue[index], () =&gt; {
          step(index + 1)
        })
      } else {
        step(index + 1)
      }
    }
  }
  // 取出队列中第一个钩子函数
  step(0)
}
</code></pre></div><p>接下来介绍导航守卫</p><div class="language- extra-class"><pre class="language-text"><code>const queue: Array&lt;?NavigationGuard&gt; = [].concat(
    // 失活的组件钩子
    extractLeaveGuards(deactivated),
    // 全局 beforeEach 钩子
    this.router.beforeHooks,
    // 在当前路由改变，但是该组件被复用时调用
    extractUpdateHooks(updated),
    // 需要渲染组件 enter 守卫钩子
    activated.map(m =&gt; m.beforeEnter),
    // 解析异步路由组件
    resolveAsyncComponents(activated)
)
</code></pre></div><p>第一步是先执行失活组件的钩子函数</p><div class="language- extra-class"><pre class="language-text"><code>function extractLeaveGuards(deactivated: Array&lt;RouteRecord&gt;): Array&lt;?Function&gt; {
// 传入需要执行的钩子函数名
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)
}
function extractGuards(
  records: Array&lt;RouteRecord&gt;,
  name: string,
  bind: Function,
  reverse?: boolean
): Array&lt;?Function&gt; {
  const guards = flatMapComponents(records, (def, instance, match, key) =&gt; {
   // 找出组件中对应的钩子函数
    const guard = extractGuard(def, name)
    if (guard) {
    // 给每个钩子函数添加上下文对象为组件自身
      return Array.isArray(guard)
        ? guard.map(guard =&gt; bind(guard, instance, match, key))
        : bind(guard, instance, match, key)
    }
  })
  // 数组降维，并且判断是否需要翻转数组
  // 因为某些钩子函数需要从子执行到父
  return flatten(reverse ? guards.reverse() : guards)
}
export function flatMapComponents (
  matched: Array&lt;RouteRecord&gt;,
  fn: Function
): Array&lt;?Function&gt; {
// 数组降维
  return flatten(matched.map(m =&gt; {
  // 将组件中的对象传入回调函数中，获得钩子函数数组
    return Object.keys(m.components).map(key =&gt; fn(
      m.components[key],
      m.instances[key],
      m, key
    ))
  }))
}
</code></pre></div><p>第二步执行全局 beforeEach 钩子函数</p><div class="language- extra-class"><pre class="language-text"><code>beforeEach(fn: Function): Function {
    return registerHook(this.beforeHooks, fn)
}
function registerHook(list: Array&lt;any&gt;, fn: Function): Function {
  list.push(fn)
  return () =&gt; {
    const i = list.indexOf(fn)
    if (i &gt; -1) list.splice(i, 1)
  }
}
</code></pre></div><p>在 VueRouter 类中有以上代码，每当给 VueRouter 实例添加 beforeEach 函数时就会将函数 push 进 beforeHooks 中。</p><p>第三步执行 <code>beforeRouteUpdate</code> 钩子函数，调用方式和第一步相同，只是传入的函数名不同，在该函数中可以访问到 <code>this</code> 对象。</p><p>第四步执行 <code>beforeEnter</code> 钩子函数，该函数是路由独享的钩子函数。</p><p>第五步是解析异步组件。</p><div class="language- extra-class"><pre class="language-text"><code>export function resolveAsyncComponents (matched: Array&lt;RouteRecord&gt;): Function {
  return (to, from, next) =&gt; {
    let hasAsync = false
    let pending = 0
    let error = null
    // 该函数作用之前已经介绍过了
    flatMapComponents(matched, (def, _, match, key) =&gt; {
    // 判断是否是异步组件
      if (typeof def === 'function' &amp;&amp; def.cid === undefined) {
        hasAsync = true
        pending++
        // 成功回调
        // once 函数确保异步组件只加载一次
        const resolve = once(resolvedDef =&gt; {
          if (isESModule(resolvedDef)) {
            resolvedDef = resolvedDef.default
          }
          // 判断是否是构造函数
          // 不是的话通过 Vue 来生成组件构造函数
          def.resolved = typeof resolvedDef === 'function'
            ? resolvedDef
            : _Vue.extend(resolvedDef)
        // 赋值组件
        // 如果组件全部解析完毕，继续下一步
          match.components[key] = resolvedDef
          pending--
          if (pending &lt;= 0) {
            next()
          }
        })
        // 失败回调
        const reject = once(reason =&gt; {
          const msg = `Failed to resolve async component ${key}: ${reason}`
          process.env.NODE_ENV !== 'production' &amp;&amp; warn(false, msg)
          if (!error) {
            error = isError(reason)
              ? reason
              : new Error(msg)
            next(error)
          }
        })
        let res
        try {
        // 执行异步组件函数
          res = def(resolve, reject)
        } catch (e) {
          reject(e)
        }
        if (res) {
        // 下载完成执行回调
          if (typeof res.then === 'function') {
            res.then(resolve, reject)
          } else {
            const comp = res.component
            if (comp &amp;&amp; typeof comp.then === 'function') {
              comp.then(resolve, reject)
            }
          }
        }
      }
    })
    // 不是异步组件直接下一步
    if (!hasAsync) next()
  }
}
</code></pre></div><p>以上就是第一个 <code>runQueue</code> 中的逻辑，第五步完成后会执行第一个 <code>runQueue</code> 中回调函数</p><div class="language- extra-class"><pre class="language-text"><code>// 该回调用于保存 `beforeRouteEnter` 钩子中的回调函数
const postEnterCbs = []
const isValid = () =&gt; this.current === route
// beforeRouteEnter 导航守卫钩子
const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)
// beforeResolve 导航守卫钩子
const queue = enterGuards.concat(this.router.resolveHooks)
runQueue(queue, iterator, () =&gt; {
  if (this.pending !== route) {
    return abort()
  }
  this.pending = null
  // 这里会执行 afterEach 导航守卫钩子
  onComplete(route)
  if (this.router.app) {
    this.router.app.$nextTick(() =&gt; {
      postEnterCbs.forEach(cb =&gt; {
        cb()
      })
    })
  }
})
</code></pre></div><p>第六步是执行 <code>beforeRouteEnter</code> 导航守卫钩子，<code>beforeRouteEnter</code> 钩子不能访问 <code>this</code> 对象，因为钩子在导航确认前被调用，需要渲染的组件还没被创建。但是该钩子函数是唯一一个支持在回调中获取 <code>this</code> 对象的函数，回调会在路由确认执行。</p><div class="language- extra-class"><pre class="language-text"><code>beforeRouteEnter (to, from, next) {
  next(vm =&gt; {
    // 通过 `vm` 访问组件实例
  })
}
</code></pre></div><p>下面来看看是如何支持在回调中拿到 <code>this</code> 对象的</p><div class="language- extra-class"><pre class="language-text"><code>function extractEnterGuards(
  activated: Array&lt;RouteRecord&gt;,
  cbs: Array&lt;Function&gt;,
  isValid: () =&gt; boolean
): Array&lt;?Function&gt; {
// 这里和之前调用导航守卫基本一致
  return extractGuards(
    activated,
    'beforeRouteEnter',
    (guard, _, match, key) =&gt; {
      return bindEnterGuard(guard, match, key, cbs, isValid)
    }
  )
}
function bindEnterGuard(
  guard: NavigationGuard,
  match: RouteRecord,
  key: string,
  cbs: Array&lt;Function&gt;,
  isValid: () =&gt; boolean
): NavigationGuard {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, cb =&gt; {
    // 判断 cb 是否是函数
    // 是的话就 push 进 postEnterCbs
      next(cb)
      if (typeof cb === 'function') {
        cbs.push(() =&gt; {
          // 循环直到拿到组件实例
          poll(cb, match.instances, key, isValid)
        })
      }
    })
  }
}
// 该函数是为了解决 issus #750
// 当 router-view 外面包裹了 mode 为 out-in 的 transition 组件 
// 会在组件初次导航到时获得不到组件实例对象
function poll(
  cb: any, // somehow flow cannot infer this is a function
  instances: Object,
  key: string,
  isValid: () =&gt; boolean
) {
  if (
    instances[key] &amp;&amp;
    !instances[key]._isBeingDestroyed // do not reuse being destroyed instance
  ) {
    cb(instances[key])
  } else if (isValid()) {
  // setTimeout 16ms 作用和 nextTick 基本相同
    setTimeout(() =&gt; {
      poll(cb, instances, key, isValid)
    }, 16)
  }
}
</code></pre></div><p>第七步是执行 <code>beforeResolve</code> 导航守卫钩子，如果注册了全局 <code>beforeResolve</code> 钩子就会在这里执行。</p><p>第八步就是导航确认，调用 <code>afterEach</code> 导航守卫钩子了。</p><p>以上都执行完成后，会触发组件的渲染</p><div class="language- extra-class"><pre class="language-text"><code>history.listen(route =&gt; {
      this.apps.forEach(app =&gt; {
        app._route = route
      })
})
</code></pre></div><p>以上回调会在 <code>updateRoute</code> 中调用</p><div class="language- extra-class"><pre class="language-text"><code>updateRoute(route: Route) {
    const prev = this.current
    this.current = route
    this.cb &amp;&amp; this.cb(route)
    this.router.afterHooks.forEach(hook =&gt; {
      hook &amp;&amp; hook(route, prev)
    })
}
</code></pre></div><p>至此，路由跳转已经全部分析完毕。核心就是判断需要跳转的路由是否存在于记录中，然后执行各种导航守卫函数，最后完成 URL 的改变和组件的渲染。</p><p>Now, let's try it 👉</p></div><div class="page-edit"><!----><div class="last-updated"><span class="prefix">Last Updated: </span><span class="time">9/20/2020, 12:22:33 PM</span></div></div><div class="page-nav"><p class="inner"><span class="prev">
        ← <a href="/Weblog/frames/vue/NextTick.html" class="prev">
          NextTick
        </a></span><span class="next"><a href="/Weblog/frames/vue/登录拦截逻辑.html">
          登录拦截逻辑
        </a> →
      </span></p></div></div></div></div>
    <script src="/Weblog/assets/js/app.05873600.js" defer></script><script src="/Weblog/assets/js/11.d51cd775.js" defer></script>
  </body>
</html>
